<div style="page-break-after:always;">&nbsp;</div>

<section data-type="chapter" id="_chapter_5_physics_libraries">
<h1>Chapter 5. Physics Libraries</h1>

<blockquote data-type="epigraph">
<p>&ldquo;A library implies an act of faith/Which generations still in darkness hid/Sign in their night in witness of the dawn.&rdquo;</p>

<p data-type="attribution">&mdash; &mdash; Victor Hugo</p>
</blockquote>

<p><a data-primary="physics" data-secondary="open-source libraries for" data-type="indexterm">&nbsp;</a> <a data-primary="physics libraries" data-type="indexterm">&nbsp;</a></p>

<p>Before we move on to anything else, let&rsquo;s revisit some of the things we&rsquo;ve done in the first four chapters. We have:</p>

<ol>
	<li>
	<p>Learned about concepts from the world of physics &mdash; What is a vector? What is a force? What is a wave? etc.</p>
	</li>
	<li>
	<p>Understood the math and algorithms behind such concepts.</p>
	</li>
	<li>
	<p>Implemented the algorithms in Processing with an object-oriented approach.</p>
	</li>
</ol>

<p>These activities have yielded a set of motion simulation examples, allowing us to creatively define the physics of the worlds we build (whether realistic or fantastical). Of course, we aren&rsquo;t the first to try this. The world of computer graphics and programming is full of source code dedicated to simulation. Just try Googling &ldquo;open-source physics engine&rdquo; and you could spend the rest of your day pouring over rich and complex code. And so we must ask the question: If a code library will take care of physics simulation, why should we bother learning how to write any of the algorithms ourselves?</p>

<p>Here is where the philosophy behind this book comes into play. While many of the libraries out there give us physics (and super awesome advanced physics at that) for free, there are significant reasons for learning the fundamentals from scratch before diving into libraries. First, without an understanding of vectors, forces, and trigonometry, we&rsquo;d be completely lost just reading the documentation of a library. Second, even though a library may take care of the math for us, it won&rsquo;t necessarily simplify our code. As we&rsquo;ll see in a moment, there can be a great deal of overhead in simply understanding how a library works and what it expects from you code-wise. Finally, as wonderful as a physics engine might be, if you look deep down into your hearts, it&rsquo;s likely that you seek to create worlds and visualizations that stretch the limits of imagination. A library is great, but it provides a limited set of features. It&rsquo;s important to know both when to live within limitations in the pursuit of a Processing project and when those limits prove to be confining.</p>

<p>This chapter is dedicated to examining two open-source physics libraries&mdash;Box2D and toxiclibs&rsquo; VerletPhysics engine. With each library, we&rsquo;ll evaluate its pros and cons and look at reasons why you might choose one of these libraries for a given project.</p>

<section data-type="sect1" id="chapter05_section1">
<h1>5.1 What Is Box2D and When Is It Useful?</h1>

<p><a data-primary="Angry Birds" data-type="indexterm">&nbsp;</a> <a data-primary="Box2D" data-type="indexterm">&nbsp;</a> <a data-primary="Catto" data-secondary="Erin" data-type="indexterm">&nbsp;</a> <a data-primary="Crayon Physics" data-type="indexterm">&nbsp;</a> <a data-primary="physics libraries" data-secondary="Box2D" data-type="indexterm">&nbsp;</a></p>

<p>Box2D began as a set of physics tutorials written in C++ by Erin Catto for the Game Developer&rsquo;s Conference in 2006. Over the last five years it has evolved into an rich and elaborate open-source physics engine. It&rsquo;s been used for countless projects, most notably highly successful games such as the award-winning puzzle game Crayon Physics and the runaway mobile and tablet hit Angry Birds.</p>

<p><a data-primary="Box2D" data-secondary="overhead with" data-type="indexterm">&nbsp;</a></p>

<p>One of the key things to realize about Box2D is that it is a true physics engine. Box2D knows nothing about computer graphics and the world of pixels; it is simply a library that takes in numbers and spits out more numbers. And what are those numbers? Meters, kilograms, seconds, etc. All of Box2D&rsquo;s measurements and calculations are for real-world measurements&mdash;only its &ldquo;world&rdquo; is a two-dimensional plane with top, bottom, left, and right edges. You tell it things like: &ldquo;The gravity of our world is 9.81 newtons per kilogram, and a circle with a radius of four meters and a mass of fifty kilograms is located ten meters above the world&rsquo;s bottom.&rdquo; Box2D will then tell you things like: &ldquo;One second later, the rectangle is at five meters from the bottom; two seconds later, it is ten meters below,&rdquo; etc. While this provides for an amazing and realistic physics engine, it also necessitates lots of complicated code in order to translate back and forth between the physics &ldquo;world&rdquo; (a key term in Box2D) and the world we want to draw on &mdash;the &ldquo;pixel&rdquo; world of Processing.</p>

<p>So when is it worth it to have this additional overhead? If I just want to simulate a circle falling down a Processing window with gravity, do I really need to write all the extra Box2D code just to get that effect? Certainly, the answer is no. We saw how to do this rather easily in the first chapter of this book. Let&rsquo;s consider another scenario. What if I want to have a hundred of those circles falling? And what if those circles aren&rsquo;t circles at all, but irregularly shaped polygons? And what if I want these polygons to bounce off each other in a realistic manner when they collide?</p>

<p><a data-primary="collisions" data-type="indexterm">&nbsp;</a> <a data-primary="physics" data-secondary="collisions" data-type="indexterm">&nbsp;</a></p>

<p>You may have noticed that the first four chapters of this book, while covering motion and forces in detail, has skipped over a rather important aspect of physics simulation&mdash;<em>collisions</em>. Let&rsquo;s pretend for a moment that you aren&rsquo;t reading a chapter about libraries and that we decided right now to cover how to handle collisions in a particle system. We&rsquo;d have to evaluate and learn two distinct algorithms that address these questions:</p>

<ol>
	<li>
	<p>How do I determine if two shapes are colliding (i.e. intersecting)?</p>
	</li>
	<li>
	<p>How do I determine the shapes&rsquo; velocity after the collision?</p>
	</li>
</ol>

<p>If we&rsquo;re thinking about shapes like rectangles or circles, question #1 isn&rsquo;t too tough. You&rsquo;ve likely encountered this before. For example, we know two circles are intersecting if the distance between them is less than the sum of their radii.</p>

<figure id="chapter05_figure1"><img alt="Figure 5.1" src="../images/chapter05/ch05_01.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<p>OK. Now that we know how to determine if two circles are colliding, how do we calculate their velocities after the collision? This is where we&rsquo;re going to stop our discussion. Why, you ask? It&rsquo;s not that understanding the math behind collisions isn&rsquo;t important or valuable. (In fact, I&rsquo;m including additional examples on the website related to collisions without a physics library.) The reason for stopping is that life is short (let this also be a reason for you to consider going outside and frolicking instead of programming altogether). We can&rsquo;t expect to master every detail of physics simulation. And while we could continue this discussion for circles, it&rsquo;s only going to lead us to wanting to work with rectangles. And strangely shaped polygons. And curved surfaces. And swinging pendulums colliding with springy springs. And and and and and.</p>

<p>Working with collisions in our Processing sketch while still having time to spend with our friends and family&mdash;that&rsquo;s the reason for this chapter. Erin Catto spent years developing solutions to these kinds of problems so you don&rsquo;t need to engineer them yourselves, at least for now.</p>

<p>In conclusion, if you find yourself describing an idea for a Processing sketch and the word &ldquo;collisions&rdquo; comes up, then it&rsquo;s likely time to learn Box2D. (We&rsquo;ll also encounter other words that might lead you down this path to Box2D, such as &ldquo;joint,&rdquo; &ldquo;hinge,&rdquo; &ldquo;pulley,&rdquo; &ldquo;motor,&rdquo; etc.)</p>
</section>

<section data-type="sect1" id="chapter05_section2">
<h1>5.2 Getting Box2D in Processing</h1>

<p><a data-primary="Box2D" data-secondary="Processing and" data-type="indexterm">&nbsp;</a> <a data-primary="Processing" data-secondary="Box2D and" data-type="indexterm">&nbsp;</a></p>

<p>So, if Box2D is a physics engine that knows nothing about pixel-based computer graphics and is written in C++, how are we supposed to use it in Processing?</p>

<p><a data-primary="Box2D" data-secondary="JBox2D and" data-type="indexterm">&nbsp;</a> <a data-primary="Java" data-type="indexterm">&nbsp;</a> <a data-primary="JBox2D" data-type="indexterm">&nbsp;</a> <a data-primary="Processing" data-secondary="JBox2D" data-type="indexterm">&nbsp;</a></p>

<p>The good news is that Box2D is such an amazing and useful library that everyone wants to use it&mdash;Flash, Javascript, Python, Ruby programmers. Oh, and Java programmers. There is something called JBox2D, a Java port of Box2D. And because Processing is built on top of Java, JBox2D can be used directly in Processing!</p>

<p>So here&rsquo;s where we are so far.</p>

<ul>
	<li>
	<p><a href="http://www.box2d.org/">Box2D site</a> for reference.</p>
	</li>
	<li>
	<p><a href="http://www.jbox2d.org/">JBox2D site</a> for Processing compatibility.</p>
	</li>
</ul>

<p><a data-primary="Box2D" data-secondary="PBox2D helper class" data-type="indexterm">&nbsp;</a> <a data-primary="PBox2D helper class" data-type="indexterm">&nbsp;</a></p>

<p>This is all you need to get started writing Box2D code in Processing. However, as we are going to see in a moment, there are several pieces of functionality we&rsquo;ll repeatedly need in our Processing code, and so it&rsquo;s worth having one additional layer between our sketches and JBox2D. I&rsquo;m calling this PBox2D&mdash;a Processing Box2D &ldquo;helper&rdquo; library included as part of this book&rsquo;s code example downloads.</p>

<ul>
	<li>
	<p><a href="http://github.com/shiffman/PBox2D">PBox2D GitHub repository</a></p>
	</li>
</ul>

<p>It&rsquo;s important to realize that PBox2D is not a Processing wrapper for all of Box2D. After all, Box2D is a thoughtfully organized and well-structured API and there&rsquo;s no reason to take it apart and re-implement it. However, it&rsquo;s useful to have a small set of functions that help you get your Box2D world set up, as well as help you figure out where to draw your Box2D shapes. And this is what PBox2D will provide.</p>

<p><a data-primary="Box2D" data-secondary="Fisica" data-type="indexterm">&nbsp;</a> <a data-primary="Fisica" data-type="indexterm">&nbsp;</a> <a data-primary="Marxer" data-secondary="Ricard" data-type="indexterm">&nbsp;</a></p>

<p>I should also mention before we move forward that there are other Processing libraries that wrap Box2D for you. One I would recommend taking a look at is <a href="http://www.ricardmarxer.com/fisica/">Fisica</a> by Ricard Marxer.</p>
</section>

<section data-type="sect1" id="chapter05_section3">
<h1>5.3 Box2D Basics</h1>

<p><a data-primary="Box2D" data-secondary="usage" data-type="indexterm">&nbsp;</a></p>

<p>Do not despair! We really are going to get to the code very soon, and in some ways we&rsquo;ll blow our previous work out of the water. But before we&rsquo;re ready to do that, it&rsquo;s important to walk through the overall process of using Box2D in Processing. Let&rsquo;s begin by writing a pseudocode generalization of all of our examples in Chapters 1 through 4.</p>

<p><strong><em>SETUP:</em></strong></p>

<ol>
	<li>
	<p>Create all the objects in our world.</p>
	</li>
</ol>

<p><strong><em>DRAW:</em></strong></p>

<ol>
	<li>
	<p>Calculate all the forces in our world.</p>
	</li>
	<li>
	<p>Apply all the forces to our objects (F = M * A).</p>
	</li>
	<li>
	<p>Update the locations of all the objects based on their acceleration.</p>
	</li>
	<li>
	<p>Draw all of our objects.</p>
	</li>
</ol>

<p>Great. Let&rsquo;s rewrite this pseudocode as it will appear in our Box2D examples.</p>

<p><strong><em>SETUP:</em></strong></p>

<ol>
	<li>
	<p>Create all the objects in our world.</p>
	</li>
</ol>

<p><strong><em>DRAW:</em></strong></p>

<ol>
	<li>
	<p>Draw all of our objects.</p>
	</li>
</ol>

<p>This, of course, is the fantasy of Box2D. We&rsquo;ve eliminated all of those painful steps of figuring out how the objects are moving according to velocity and acceleration. Box2D is going to take care of this for us! The good news is that this does accurately reflect the overall process. Let&rsquo;s imagine Box2D as a magic box.</p>

<p>In <strong function="">setup()</strong>, we&rsquo;re going to say to Box2D: &ldquo;Hello there. Here are all of the things I want in my world.&rdquo; In <strong function="">draw()</strong>, we&rsquo;re going to politely ask Box2D: &ldquo;Oh, hello again. If it&rsquo;s not too much trouble, I&rsquo;d like to draw all of those things in my world. Could you tell me where they are?&rdquo;</p>

<p>The bad news: it&rsquo;s not as simple as the above explanation would lead you to believe. For one, making the stuff that goes in the Box2D world involves wading through the documentation for how different kinds of shapes are built and configured. Second, we have to remember that we can&rsquo;t tell Box2D anything about pixels, as it will simply get confused and fall apart. Before we tell Box2D what we want in our world, we have to convert our pixel units to Box2D &ldquo;world&rdquo; units. And the same is true when it comes time to draw our stuff. Box2D is going to tell us the location of the things in its world, which we then have to translate for the pixel world.</p>

<ol>
	<li>
	<p>Create everything that lives in our pixel world.</p>
	</li>
	<li>
	<p>Translate the pixel world into the Box2D world.</p>
	</li>
</ol>

<ol>
	<li>
	<p>Ask Box2D where everything is.</p>
	</li>
	<li>
	<p>Translate Box2D&rsquo;s answer into the pixel world.</p>
	</li>
	<li>
	<p>Draw everything.</p>
	</li>
</ol>

<p>Now that we understand that anything we create in our Processing sketch has to be placed into the Box2D world, let&rsquo;s look at an overview of the elements that make up that world.</p>

<p><a data-primary="body (Box2D element)" data-type="indexterm">&nbsp;</a> <a data-primary="Box2D" data-secondary="core elements" data-type="indexterm">&nbsp;</a> <a data-primary="fixture (Box2D element)" data-type="indexterm">&nbsp;</a> <a data-primary="joint (Box2D element)" data-type="indexterm">&nbsp;</a> <a data-primary="shape (Box2D element)" data-type="indexterm">&nbsp;</a> <a data-primary="Vec2 (Box2D element)" data-type="indexterm">&nbsp;</a> <a data-primary="vectors" data-secondary="Vec2 (Box2D element)" data-type="indexterm">&nbsp;</a> <a data-primary="World class (Box2D)" data-type="indexterm">&nbsp;</a></p>

<ol>
	<li>
	<p><strong><em>World</em></strong>: Manages the physics simulation. It knows everything about the overall coordinate space and also stores lists of every element in the world (see 2-4 below).</p>
	</li>
	<li>
	<p><strong><em>Body</em></strong>: Serves as the primary element in the Box2D world. It has a location. It has a velocity. Sound familiar? The <strong klass="">Body</strong> is essentially the class we&rsquo;ve been writing on our own in our vectors and forces examples.</p>
	</li>
	<li>
	<p><strong><em>Shape</em></strong>: Keeps track of all the necessary collision geometry attached to a body.</p>
	</li>
	<li>
	<p><strong><em>Fixture</em></strong>: Attaches a shape to a body and sets properties such as density, friction, and restitution.</p>
	</li>
	<li>
	<p><strong><em>Joint</em></strong>: Acts as a connection between two bodies (or between one body and the world itself).</p>
	</li>
</ol>

<p>In the next four sections, we are going to walk through each of the above elements in detail, building several examples along the way. But first there is one other important element we should briefly discuss.</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.&nbsp;&nbsp; <strong><em>Vec2</em></strong>: Describes a vector in the Box2D world.</p>

<p>And so here we are, arriving with trepidation at an unfortunate truth in the world of using physics libraries. Any physics simulation is going to involve the concept of a vector. This is the good part. After all, we just spent several chapters familiarizing ourselves with what it means to describe motion and forces with vectors. We don&rsquo;t have to learn anything new conceptually.</p>

<p><a data-primary="Box2D" data-secondary="PVector vs." data-type="indexterm">&nbsp;</a> <a data-primary="PVector class (Processing)" data-secondary="Box2D vs." data-type="indexterm">&nbsp;</a></p>

<p>Now for the part that makes the single tear fall from my eye: we don&rsquo;t get to use <strong klass="">PVector</strong>. It&rsquo;s nice that Processing has <strong klass="">PVector</strong> for us, but anytime you use a physics library you will probably discover that the library includes its own vector implementation. This makes sense, after all; why should Box2D be expected to know about <strong klass="">PVector</strong>? And in many cases, the physics engine will want to implement a vector class in a specific way so that it is especially compatible with the rest of the library&rsquo;s code. So while we don&rsquo;t have to learn anything new conceptually, we do have to get used to some new naming conventions and syntax. Let&rsquo;s quickly demonstrate a few of the basics in <strong klass="">Vec2</strong> as compared to those in <strong klass="">PVector</strong>.</p>

<p>Let&rsquo;s say we want to add two vectors together.</p>

<p><a data-primary="add() function (Vec2 class)" data-type="indexterm">&nbsp;</a> <a data-primary="addLocal() function (Vec2)" data-type="indexterm">&nbsp;</a> <a data-primary="Vec2 (Box2D element)" data-secondary="adding vectors with" data-type="indexterm">&nbsp;</a></p>

<table class="code">
	<tbody>
		<tr>
			<th>PVector</th>
			<th>Vec2</th>
		</tr>
		<tr>
			<td>
			<pre>
PVector a = new PVector(1,-1);
PVector b = new PVector(3,4);
a.add(b);
</pre>
			</td>
			<td>
			<pre>
Vec2 a = new Vec2(1,-1);
Vec2 b = new Vec2(3,4);
a.addLocal(b);
</pre>
			</td>
		</tr>
		<tr>
			<td>
			<pre>
PVector a = new PVector(1,-1);
PVector b = new PVector(3,4);
PVector c = PVector.add(a,b);
</pre>
			</td>
			<td>
			<pre>
Vec2 a = new Vec2(1,-1);
Vec2 b = new Vec2(3,4);
Vec2 c = a.add(b);
</pre>
			</td>
		</tr>
	</tbody>
</table>

<p><a data-primary="Vec2 (Box2D element)" data-secondary="multiplying vectors with" data-type="indexterm">&nbsp;</a> <a data-primary="Vec2 (Box2D element)" data-secondary="scaling vectors with" data-type="indexterm">&nbsp;</a></p>

<p>How about if we want to multiply and scale them?</p>

<table class="code">
	<tbody>
		<tr>
			<th>PVector</th>
			<th>Vec2</th>
		</tr>
		<tr>
			<td>
			<pre>
PVector a = new PVector(1,-1);
float n = 5;
a.mult(n);
</pre>
			</td>
			<td>
			<pre>
Vec2 a = new Vec2(1,-1);
float n = 5;
a.mulLocal(n);
</pre>
			</td>
		</tr>
		<tr>
			<td>
			<pre>
PVector a = new PVector(1,-1);
float n = 5;
PVector c = PVector.mult(a,n);
</pre>
			</td>
			<td>
			<pre>
Vec2 a = new Vec2(1,-1);
float n = 5;
Vec2 c = a.mul(n);
</pre>
			</td>
		</tr>
	</tbody>
</table>

<p>Magnitude and normalize?</p>

<p><a data-primary="Vec2 (Box2D element)" data-secondary="manitude" data-tertiary="finding" data-type="indexterm">&nbsp;</a> <a data-primary="Vec2 (Box2D element)" data-secondary="normalizing vectors" data-type="indexterm">&nbsp;</a></p>

<table class="code">
	<tbody>
		<tr>
			<th>PVector</th>
			<th>Vec2</th>
		</tr>
		<tr>
			<td>
			<pre>
PVector a = new PVector(1,-1);
float m = a.mag();
a.normalize();
</pre>
			</td>
			<td>
			<pre>
Vec2 a = new Vec2(1,-1);
float m = a.length();
a.normalize();
</pre>
			</td>
		</tr>
	</tbody>
</table>

<p><a data-primary="JBox2D" data-secondary="full documentation for" data-type="indexterm">&nbsp;</a></p>

<p>As you can see, the concepts are the same, but the function names and the arguments are slightly different. For example, instead of static and non-static <strong function="">add()</strong> and <strong function="">mult()</strong>, if a <strong klass="">Vec2</strong> is altered, the word &ldquo;local&rdquo; is included in the function name&mdash;<strong function="">addLocal()</strong>, <strong function="">multLocal()</strong>.</p>

<p>We&rsquo;ll cover the basics of what you need to know here, but if you are looking for more, full documentation of <strong klass="">Vec2</strong> can be found by downloading the <a href="http://code.google.com/p/jbox2d/">JBox2D source code</a>.</p>
</section>

<section data-type="sect1" id="chapter05_section4">
<h1>5.4 Living in a Box2D World</h1>

<p><a data-primary="World class (Box2D)" data-type="indexterm">&nbsp;</a></p>

<p>The Box2D <strong klass="">World</strong> object is in charge of everything. It manages the coordinate space of the world, all of the stuff that lives in the world, and decides when time moves forward in the world.</p>

<p><a data-primary="PBox2D helper class" data-secondary="createWorld() function" data-type="indexterm">&nbsp;</a> <a data-primary="World class (Box2D)" data-secondary="createWorld() function (PBox2D)" data-type="indexterm">&nbsp;</a></p>

<p>In order to have Box2D as part of our Processing sketches, the <strong klass="">World</strong> is the very first thing that needs to be set up. Here is where PBox2D comes in handy and takes care of making the world for us.</p>

<pre data-code-language="java" data-type="programlisting">
PBox2D box2d;

void setup() {
  box2d = new PBox2D(this);
  // Initializes a Box2D world with default settings
  box2d.createWorld();
}</pre>

<p>When you call <strong function="">createWorld()</strong>, PBox2D will set up a default gravity for you (pointing down); however, you can always alter the gravity of your world by saying:</p>

<p><a data-primary="setGravity() function (World class)" data-type="indexterm">&nbsp;</a></p>

<pre data-code-language="java" data-type="programlisting">
  box2d.setGravity(0, -10);</pre>

<p>It&rsquo;s worth noting that gravity doesn&rsquo;t have to be fixed, nor does it always have to point downwards; you can adjust the gravity vector while your program is running. Gravity can be turned off by setting it to a (0,0) vector.</p>

<p>So, what are those numbers 0 and -10? This should remind us of one of the most important details of using Box2D: the Box2D coordinate system is not your pixel coordinate system! Let&rsquo;s look at how Box2D and a Processing window think differently of their worlds.</p>

<p><a data-primary="Box2D" data-secondary="coordinate system vs. Processing" data-type="indexterm">&nbsp;</a> <a data-primary="coordinate systems" data-secondary="Box2D vs. Processing" data-type="indexterm">&nbsp;</a> <a data-primary="Processing" data-secondary="coordinate systems vs. Box2D" data-type="indexterm">&nbsp;</a></p>

<figure id="chapter05_figure2"><img alt="Figure 5.2" src="../images/chapter05/ch05_02.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<p>Notice how in Box2D <em>(0,0)</em> is in the center and <em>up</em> is the positive direction along the y-axis! Box2D&rsquo;s coordinate system is just like that lovely old-fashioned Cartesian one with <em>(0,0)</em> in the center and <em>up</em> pointing in a positive direction. Processing, on the other hand, uses a traditional computer graphics coordinate system where <em>(0,0)</em> is in the top left corner and <em>down</em> is the positive direction along the y-axis. This is why if we want objects to fall down with gravity, we need to give Box2D a gravity force with a negative y-value.</p>

<pre data-code-language="java" data-type="programlisting">
Vec2 gravity = new Vec2(0, -10);</pre>

<p>Luckily for us, if we prefer to think in terms of pixel coordinates (which as Processing programmers, we are likely to do), PBox2D offers a series of helper functions that convert between pixel space and Box2D space. Before we move onto the next section and begin creating Box2D bodies, let&rsquo;s take a look at how these helper functions work.</p>

<p><a data-primary="coordPixelsToWorld() function (PBox2D)" data-type="indexterm">&nbsp;</a> <a data-primary="PBox2D helper class" data-secondary="coordinate systems" data-tertiary="converting between" data-type="indexterm">&nbsp;</a></p>

<p>Let&rsquo;s say we want to tell Box2D where the mouse is in its world. We know the mouse is located at <strong class="var">(mouseX,mouseY)</strong> in Processing. To convert it, we say we want to convert a &ldquo;coordinate&rdquo; from &ldquo;pixels&rdquo; to &ldquo;world&rdquo;&mdash;<strong function="">coordPixelsToWorld()</strong>. Or:</p>

<pre data-code-language="java" data-type="programlisting">
// Convert mouseX,mouseY to
// coordinate in Box2D world.
Vec2 mouseWorld = box2d.coordPixelsToWorld(mouseX,mouseY);</pre>

<p>What if we had a Box2D world coordinate and wanted to translate it to our pixel space?</p>

<pre data-code-language="java" data-type="programlisting">
// To demonstrate, let&rsquo;s just make up a world position.
Vec2 worldPos = new Vec2(-10,25);

// Convert to pixel space.
// This is necessary because ultimately we
// are going to want to draw the elements in our window.
Vec2 pixelPos = box2d.coordWorldToPixels(worldPos);
ellipse(pixelPos.x, pixelPos.y,16,16);</pre>

<p>PBox2D has a set of functions to take care of translating back and forth between the Box2D world and pixels. It&rsquo;s probably easier to learn about all of these functions during the course of actually implementing our examples, but let&rsquo;s quickly look over the list of the possibilities.</p>

<p><a data-primary="coordWorldToPixels() function (PBox2D)" data-type="indexterm">&nbsp;</a> <a data-primary="scalarPixelsToWorld() function (PBox2D)" data-type="indexterm">&nbsp;</a> <a data-primary="scalarWorldToPixels() function (PBox2D)" data-type="indexterm">&nbsp;</a></p>

<table class="code">
	<tbody>
		<tr>
			<th>Task</th>
			<th>Function</th>
		</tr>
		<tr>
			<td>Convert location from World to Pixels</td>
			<td>
			<pre>
Vec2 coordWorldToPixels(Vec2 world)</pre>
			</td>
		</tr>
		<tr>
			<td>Convert location from World to Pixels</td>
			<td>
			<pre>
Vec2 coordWorldToPixels(float worldX, float worldY)</pre>
			</td>
		</tr>
		<tr>
			<td>Convert location from Pixels to World</td>
			<td>
			<pre>
Vec2 coordPixelsToWorld(Vec2 screen)</pre>
			</td>
		</tr>
		<tr>
			<td>Convert location from Pixels to World</td>
			<td>
			<pre>
Vec2 coordPixelsToWorld(float pixelX, float pixelY)</pre>
			</td>
		</tr>
		<tr>
			<td>Scale a dimension (such as height, width, or radius) from Pixels to World</td>
			<td>
			<pre>
float scalarPixelsToWorld(float val)</pre>
			</td>
		</tr>
		<tr>
			<td>Scale a dimension from World to Pixels</td>
			<td>
			<pre>
float scalarWorldToPixels(float val)</pre>
			</td>
		</tr>
	</tbody>
</table>

<p>There are also additional functions that allow you to pass or receive a <strong klass="">PVector</strong> when translating back and forth, but since we are only working with Box2D in the examples in this chapter, it&rsquo;s easiest to stick with the <strong klass="">Vec2</strong> class for all vectors.</p>

<p>Once the world is initialized, we are ready to actually put stuff in the world&mdash;Box2D bodies.</p>
</section>

<section data-type="sect1" id="chapter05_section5">
<h1>5.5 Building a Box2D Body</h1>

<p><a data-primary="body (Box2D element)" data-secondary="building" data-type="indexterm">&nbsp;</a></p>

<p>A Box2D body is the primary element in the Box2D world. It&rsquo;s the equivalent to the <strong klass="">Mover</strong> class we built on our own in previous chapters&mdash;the thing that moves around the space and experiences forces. It can also be static (meaning fixed and not moving). It&rsquo;s important to note, however, that a body has no geometry; it isn&rsquo;t anything physical. Rather, bodies have Box2D shapes attached to them. (This way, a body can be a single rectangle or a rectangle attached to a circle, etc.) We&rsquo;ll look at shapes in a moment; first, let&rsquo;s build a body.</p>

<section data-type="sect2" id="_step_1_define_a_body">
<h2>Step 1: Define a body.</h2>

<p><a data-primary="body (Box2D element)" data-secondary="BodyDef type" data-type="indexterm">&nbsp;</a> <a data-primary="BodyDef type (body element)" data-type="indexterm">&nbsp;</a></p>

<p>The first thing we have to do is create a &ldquo;body definition.&rdquo; This will let us define the properties of the body we intend to make. This may seem a bit awkward at first, but it&rsquo;s how Box2D is structured. Anytime you want to make a &ldquo;thing,&rdquo; you have to make a &ldquo;thing definition&rdquo; first. This will hold true for bodies, shapes, and joints.</p>

<pre data-code-language="java" data-type="programlisting">
// Make a body definition before making a Body.
BodyDef bd = new BodyDef();</pre>
</section>

<section data-type="sect2" id="_step_2_configure_the_body_definition">
<h2>Step 2: Configure the body definition.</h2>

<p><a data-primary="BodyDef type (body element)" data-secondary="configuring" data-type="indexterm">&nbsp;</a></p>

<p>The body definition is where we can set specific properties or attributes of the body we intend to make. One attribute of a body, for example, is its starting location. Let&rsquo;s say we want to position the body in the center of the Processing window.</p>

<pre data-code-language="java" data-type="programlisting">
// A Vec2 in the center of the Processing window
Vec2 center = new Vec2(width/2,height/2);</pre>

<p>Danger, danger! I&rsquo;m not going to address this with every single example, but it&rsquo;s important to at least point out the perilous path we are taking with the above line of code. Remember, if we are going to tell Box2D where we want the body to start, we must give Box2D a world coordinate! Yes, we want to think of its location in terms of pixels, but Box2D doesn&rsquo;t care. And so before we pass that position to the body definition, we must make sure to use one of our helper conversion functions.</p>

<pre data-code-language="java" data-type="programlisting">
// A Vec2 in the center of the
// Processing window converted to Box2D World coordinates!
Vec2 center = box2d.coordPixelsToWorld(width/2,height/2));
// Setting the position attribute of the Box2D body definition
bd.position.set(center);</pre>

<p><a data-primary="body (Box2D element)" data-secondary="types of" data-type="indexterm">&nbsp;</a> <a data-primary="dynamic (body type)" data-type="indexterm">&nbsp;</a> <a data-primary="kinematic (body type)" data-type="indexterm">&nbsp;</a> <a data-primary="static (body type)" data-type="indexterm">&nbsp;</a></p>

<p>The body definition must also specify the &ldquo;type&rdquo; of body we want to make. There are three possibilities:</p>

<ul>
	<li>
	<p><strong><em>Dynamic.</em></strong> This is what we will use most often&mdash;a &ldquo;fully simulated&rdquo; body. A dynamic body moves around the world, collides with other bodies, and responds to the forces in its environment.</p>
	</li>
	<li>
	<p><strong><em>Static.</em></strong> A static body is one that cannot move (as if it had an infinite mass). We&rsquo;ll use static bodies for fixed platforms and boundaries.</p>
	</li>
	<li>
	<p><strong><em>Kinematic.</em></strong> A kinematic body can be moved manually by setting its velocity directly. If you have a user-controlled object in your world, you can use a kinematic body. Note that kinematic bodies collide only with dynamic bodies and not with other static or kinematic ones.</p>
	</li>
</ul>

<p>There are several other properties you can set in the body definition. For example, if you want your body to have a fixed rotation (i.e. never rotate), you can say:</p>

<pre data-code-language="java" data-type="programlisting">
bd.fixedRotation = true;</pre>

<p>You can also set a value for linear or angular damping, so that the object continuously slows as if there is friction.</p>

<pre data-code-language="java" data-type="programlisting">
bd.linearDamping = 0.8;
bd.angularDamping = 0.9;</pre>

<p><a data-primary="body (Box2D element)" data-secondary="bullet setting for" data-type="indexterm">&nbsp;</a></p>

<p>In addition, fast-moving objects in Box2D should be set as bullets. This tells the Box2D engine that the object may move very quickly and to check its collisions more carefully so that it doesn&rsquo;t accidentally jump over another body.</p>

<pre data-code-language="java" data-type="programlisting">
bd.bullet = true;</pre>
</section>

<section data-type="sect2" id="_step_3_create_the_body">
<h2>Step 3: Create the body.</h2>

<p><a data-primary="body (Box2D element)" data-secondary="object" data-tertiary="creating" data-type="indexterm">&nbsp;</a> <a data-primary="createBody() function (PBox2D)" data-type="indexterm">&nbsp;</a></p>

<p>Once we&rsquo;re done with the definition (<strong klass="">BodyDef</strong>), we can create the <strong klass="">Body</strong> object itself. PBox2D provides a helper function for this&mdash;<strong function="">createBody</strong>().</p>

<pre data-code-language="java" data-type="programlisting">
// The Body object is created by passing in the Body
// Definition. (This allows for making multiple bodies from
// one definition.)
Body body = box2d.createBody(bd);</pre>
</section>

<section data-type="sect2" id="_step_4_set_any_other_conditions_for_the_body_s_starting_state">
<h2>Step 4: Set any other conditions for the body&rsquo;s starting state.</h2>

<p><a data-primary="body (Box2D element)" data-secondary="initial settings for" data-type="indexterm">&nbsp;</a></p>

<p>Finally, though not required, if you want to set any other initial conditions for the body, such as linear or angular velocity, you can do so with the newly created <strong klass="">Body</strong> object.</p>

<pre data-code-language="java" data-type="programlisting">
// Setting an arbitrary initial velocity
body.setLinearVelocity(new Vec2(0,3));
// Setting an arbitrary initial angular velocity
body.setAngularVelocity(1.2);</pre>
</section>
</section>

<section data-type="sect1" id="chapter05_section6">
<h1>5.6 Three&rsquo;s Company: Bodies and Shapes and Fixtures</h1>

<p><a data-primary="Shape (Box2D element)" data-type="indexterm">&nbsp;</a></p>

<p>A body on its own doesn&rsquo;t physically exist in the world. It&rsquo;s like a soul with no human form to inhabit. For a body to have mass, we must first define a shape and attach that shape to the body with something known as a fixture.</p>

<p><a data-primary="Shape (Box2D element)" data-secondary="friction attribute" data-type="indexterm">&nbsp;</a> <a data-primary="Shape (Box2D element)" data-secondary="restitution attribute" data-type="indexterm">&nbsp;</a></p>

<p>The job of the Box2D <strong klass="">Shape</strong> class is to keep track of all the necessary collision geometry attached to a body. A shape also has several important properties that affect the body&rsquo;s motion. There is density, which ultimately determines that body&rsquo;s mass. Shapes also have <em>friction</em> and <em>restitution</em> (&ldquo;bounciness&rdquo;) which will be defined through a fixture. One of the nice things about Box2D&rsquo;s methodology, which separates the concepts of bodies and shapes into two separate objects, is that you can attach multiple shapes to a single body in order to create more complex forms. We&rsquo;ll see this in a future example.</p>

<p>To create a shape, we need to first decide what kind of shape we want to make. For most non-circular shapes, a <strong klass="">PolygonShape</strong> object will work just fine. For example, let&rsquo;s look at how we define a rectangle.</p>

<section data-type="sect2" id="_step_1_define_a_shape">
<h2>Step 1: Define a shape.</h2>

<p><a data-primary="Shape (Box2D element)" data-secondary="defining" data-type="indexterm">&nbsp;</a></p>

<pre data-code-language="java" data-type="programlisting">
// Define the shape: a polygon.
PolygonShape ps = new PolygonShape();</pre>

<p>Next up, we have to define the width and height of the rectangle. Let&rsquo;s say we want our rectangle to be 150&times;100 pixels. Remember, pixel units are no good for Box2D shapes! So we have to use our helper functions to convert them first.</p>

<pre data-code-language="java" data-type="programlisting">
//[full] Scale dimensions from pixels to Box2D world.
float box2Dw = box2d.scalarPixelsToWorld(150);
float box2Dh = box2d.scalarPixelsToWorld(100);
//[end]

// Use setAsBox() function to define shape as a rectangle.
ps.setAsBox(box2Dw, box2Dh);</pre>
</section>

<section data-type="sect2" id="_step_2_create_a_fixture">
<h2>Step 2: Create a fixture.</h2>

<p><a data-primary="fixture (Box2D element)" data-secondary="creating" data-type="indexterm">&nbsp;</a></p>

<p>The shape and body are made as two separate entities. In order to attach a shape to a body, we must make a fixture. A fixture is created, just as with the body, via a fixture definition (i.e. <strong klass="">FixtureDef</strong> class) and assigned a shape.</p>

<pre data-code-language="java" data-type="programlisting">
FixtureDef fd = new FixtureDef();
// The fixture is assigned the PolygonShape we just made.
fd.shape = ps;</pre>

<p>Once we have the fixture definition, we can set parameters that affect the physics for the shape being attached.</p>

<pre data-code-language="java" data-type="programlisting">
// The coefficient of friction for the
// shape, typically between 0 and 1
fd.friction = 0.3;
// The Shape&rsquo;s restitution (i.e. elasticity),
// typically between 0 and 1
fd.restitution = 0.5;
// The Shape&rsquo;s density, measured in
// kilograms per meter squared
fd.density = 1.0;</pre>
</section>

<section data-type="sect2" id="_step_3_attach_the_shape_to_the_body_with_the_fixture">
<h2>Step 3: Attach the shape to the body with the fixture.</h2>

<p><a data-primary="body (Box2D element)" data-secondary="attaching fixture element to" data-type="indexterm">&nbsp;</a> <a data-primary="createFixture() function (PBox2D)" data-type="indexterm">&nbsp;</a> <a data-primary="fixture (Box2D element)" data-secondary="attaching to body element" data-type="indexterm">&nbsp;</a></p>

<p>Once the fixture is defined, all we have left to do is attach the shape to the body with the fixture by calling the <strong function="">createFixture()</strong> function.</p>

<pre data-code-language="java" data-type="programlisting">
// Creates the Fixture and attaches the Shape to the Body object
body.createFixture(fd);</pre>

<p>I should note that Step 2 can be skipped if you do not need to set the physics properties. (Box2D will use default values.) You can create a fixture and attach the shape all in one step by saying:</p>

<pre data-code-language="java" data-type="programlisting">
// Creates the Fixture and attaches the Shape with a density of 1
body.createFixture(ps,1);</pre>

<p>While most of our examples will take care of attaching shapes only once when the body is first built, this is not a limitation of Box2D. Box2D allows for shapes to be created and destroyed on the fly.</p>

<p>Before we put any of this code we&rsquo;ve been writing into a Processing sketch, let&rsquo;s review all the steps we took to construct a Body.</p>

<ol>
	<li>
	<p>Define a body using a <strong klass="">BodyDef</strong> object (set any properties, such as location).</p>
	</li>
	<li>
	<p>Create the <strong klass="">Body</strong> object from the body definition.</p>
	</li>
	<li>
	<p>Define a <strong klass="">Shape</strong> object using <strong klass="">PolygonShape</strong>, <strong klass="">CircleShape</strong>, or any other shape class.</p>
	</li>
	<li>
	<p>Define a fixture using <strong klass="">FixtureDef</strong> and assign the fixture a shape (set any properties, such as friction, density, and restitution).</p>
	</li>
	<li>
	<p>Attach the shape to the body.</p>
	</li>
</ol>

<pre data-code-language="java" data-type="programlisting">
// Step 1. Define the body.
BodyDef bd = new BodyDef();
bd.position.set(box2d.coordPixelsToWorld(width/2,height/2));

// Step 2. Create the body.
Body body = box2d.createBody(bd);

// Step 3. Define the shape.
PolygonShape ps = new PolygonShape();
float w = box2d.scalarPixelsToWorld(150);
float h = box2d.scalarPixelsToWorld(100);
ps.setAsBox(w, h);

// Step 4. Define the fixture.
FixtureDef fd = new FixtureDef();
fd.shape = ps;
fd.density = 1;
fd.friction = 0.3;
fd.restitution = 0.5;

// Step 5. Attach the shape to the body with the Fixture.
body.createFixture(fd);</pre>

<div data-type="exercise" id="chapter05_exercise1">
<h5>Exercise 5.1</h5>

<p>Knowing what you know about Box2D so far, fill in the blank in the code below that demonstrates how to make a circular shape in Box2D.</p>

<pre data-code-language="java" data-type="programlisting">
CircleShape cs = new CircleShape();
float radius = 10;
cs.m_radius = ____________________;
FixtureDef fd = new FixtureDef();
fd.shape = cs;
fd.density = 1;
fd.friction = 0.1;
fd.restitution = 0.3;

body.createFixture(fd);</pre>
</div>
</section>
</section>

<section data-type="sect1" id="chapter05_section7">
<h1>5.7 Box2D and Processing: Reunited and It Feels So Good</h1>

<p>Once a body is made, it lives in the Box2D physics world. Box2D will always know it&rsquo;s there, check it for collisions, move it appropriately according to the forces, etc. It&rsquo;ll do all that for you without you having to lift a finger! What it won&rsquo;t do, however, is display the body for you. This is a good thing. This is your time to shine. When working with Box2D, what we&rsquo;re essentially saying is, &ldquo;I want to be the designer of my world, and I want you, Box2D, to compute all the physics.&rdquo;</p>

<p><a data-primary="body lists" data-secondary="maintaining in Processing" data-type="indexterm">&nbsp;</a> <a data-primary="getBodyList() function (World class)" data-type="indexterm">&nbsp;</a> <a data-primary="Processing" data-secondary="body lists" data-tertiary="maintaining" data-type="indexterm">&nbsp;</a> <a data-primary="World class (Box2D)" data-secondary="getBodyList() function" data-type="indexterm">&nbsp;</a></p>

<p>Now, Box2D will keep a list of all the bodies that exist in the world. This can be accessed by calling the World object&rsquo;s <strong function="">getBodyList()</strong> function. Nevertheless, what I&rsquo;m going to demonstrate here is a technique for keeping your own body lists. Yes, this may be a bit redundant and we perhaps sacrifice a bit of efficiency. But we more than make up for that with ease of use. This methodology will allow us to program like we&rsquo;re used to in Processing, and we can easily keep track of which bodies are which and render them appropriately. Let&rsquo;s consider the structure of the following Processing sketch:</p>

<figure id="chapter05_figure3"><img alt="Figure 5.3" src="../images/chapter05/ch05_03.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<p>This looks like any ol&rsquo; Processing sketch. We have a main tab called &ldquo;Boxes&rdquo; and a &ldquo;Boundary&rdquo; and a &ldquo;Box&rdquo; tab. Let&rsquo;s think about the Box tab for a moment. The Box tab is where we will write a simple class to describe a <strong klass="">Box</strong> object, a rectangular body in our world.</p>

<pre data-code-language="java" data-type="programlisting">
class Box  {

  //[full] Our Box object has an x,y location and a width and a height.
  float x,y;
  float w,h;
  //[end]

  Box(float x_, float y_) {
    //[full] The location is initalized in the constructor via arguments
    x = x_;
    y = y_;
    //[end]
    w = 16;
    h = 16;
  }

  void display() {
    // We draw the Box object using Processing&rsquo;s rect() function.
    fill(175);
    stroke(0);
    rectMode(CENTER);
    rect(x,y,w,h);
  }
}</pre>

<p>Let&rsquo;s write a main tab that creates a new <strong klass="">Box</strong> whenever the mouse is pressed and stores all the <strong klass="">Box</strong> objects in an <strong klass="">ArrayList</strong>. (This is very similar to our approach in the particle system examples from Chapter 4.)</p>

<figure class="screenshot"><img alt="ch05 ex01" src="../images/chapter05/ch05_ex01.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<p><strong example="">Example 5.1: A comfortable and cozy Processing sketch that needs a little Box2D</strong></p>

<pre data-code-language="java" data-type="programlisting">
// A list to store all Box objects
ArrayList&lt;Box&gt; boxes;

void setup() {
  size(400,300);
  boxes = new ArrayList&lt;Box&gt;();
}

void draw() {
  background(255);

  //[full] When the mouse is pressed, add a new Box object.
  if (mousePressed) {
    Box p = new Box(mouseX,mouseY);
    boxes.add(p);
  }
  //[end]

  //[full] Display all the Box objects.
  for (Box b: boxes) {
    b.display();
  }
  //[end]
}</pre>

<p>Now, here&rsquo;s our assignment. Take the above example verbatim, but instead of drawing fixed boxes on the screen, draw boxes that experience physics (via Box2D) as soon as they appear.</p>

<p>We&rsquo;ll need two major steps to accomplish our goal.</p>

<section data-type="sect2" id="_step_1_add_box2d_to_our_main_program_i_e_setup_and_draw">
<h2>Step 1: Add Box2D to our main program (i.e. setup() and draw()).</h2>

<p><a data-primary="Processing" data-secondary="Box2D objects" data-tertiary="adding to projects" data-type="indexterm">&nbsp;</a></p>

<p>This part is not too tough. We saw this already in our discussion of building a Box2D world. This is taken care of for us by the PBox2D helper class. We can create a PBox2D object and initialize it in <strong function="">setup()</strong>.</p>

<pre data-code-language="java" data-type="programlisting">
PBox2D box2d;

void setup() {
  //[full] Initialize and create the Box2D world.
  box2d = new PBox2D(this);
  box2d.createWorld();
  //[end]
}</pre>

<p><a data-primary="step() function (Box2D)" data-type="indexterm">&nbsp;</a></p>

<p>Then in <strong function="">draw()</strong>, we need to make sure we call one very important function: <strong function="">step()</strong>. Without this function, nothing would ever happen! <strong function="">step()</strong> advances the Box2D world a step further in time. Internally, Box2D sweeps through and looks at all of the Bodies and figures out what to do with them. Just calling <strong function="">step()</strong> on its own moves the Box2D world forward with default settings; however, it is customizable (and this is documented in the PBox2D source).</p>

<pre data-code-language="java" data-type="programlisting">
void draw() {
  // We must always step through time!
  box2d.step();
}</pre>
</section>

<section data-type="sect2" id="_step_2_link_every_processing_box_object_with_a_box2d_body_object">
<h2>Step 2: Link every Processing Box object with a Box2D Body object.</h2>

<p>As of this moment, the <strong klass="">Box</strong> class includes variables for location and width and height. What we now want to say is:</p>

<p>&ldquo;I hereby relinquish the command of this object&rsquo;s position to Box2D. I no longer need to keep track of anything related to location, velocity, and acceleration. Instead, I only need to keep track of a Box2D body and have faith that Box2D will do the rest.&rdquo;</p>

<pre data-code-language="java" data-type="programlisting">
class Box  {

  // Instead of any of the usual variables,
  // we will store a reference to a Box2D body.
  Body body;
  float w;
  float h;</pre>

<p>We don&rsquo;t need <em>(x,y)</em> anymore since, as we&rsquo;ll see, the body itself will keep track of its location. The body technically could also keep track of the width and height for us, but since Box2D isn&rsquo;t going to do anything to alter those values over the life of the <strong klass="">Box</strong> object, we might as well just hold onto them ourselves until it&rsquo;s time to draw the <strong klass="">Box</strong>.</p>

<p>Then, in our constructor, in addition to initializing the width and height, we can go ahead and include all of the body and shape code we learned in the previous two sections!</p>

<pre data-code-language="java" data-type="programlisting">
  Box() {
    w = 16;
    h = 16;

    // Build body.
    BodyDef bd = new BodyDef();
    bd.type = BodyType.DYNAMIC;
    bd.position.set(box2d.coordPixelsToWorld(mouseX,mouseY));
    body = box2d.createBody(bd);

    // Build shape.
    PolygonShape ps = new PolygonShape();
    //[full] Box2D considers the width and height of a rectangle to be the distance from the center to the edge (so half of what we normally think of as width or height).
    float box2dW = box2d.scalarPixelsToWorld(w/2);
    float box2dH = box2d.scalarPixelsToWorld(h/2);
    //[end]
    ps.setAsBox(box2dW, box2dH);

    FixtureDef fd = new FixtureDef();
    fd.shape = ps;
    fd.density = 1;
    // Set physics parameters.
    fd.friction = 0.3;
    fd.restitution = 0.5;

    // Attach the Shape to the Body with the Fixture.
    body.createFixture(fd);
 }</pre>

<p>OK, we&rsquo;re almost there. Before we introduced Box2D, it was easy to draw the <strong klass="">Box</strong>. The object&rsquo;s location was stored in variables <strong class="var">x</strong> and <strong class="var">y</strong>.</p>

<pre data-code-language="java" data-type="programlisting">
  //[full] Drawing the object using rect()
  void display() {
    fill(175);
    stroke(0);
    rectMode(CENTER);
    rect(x,y,w,h);
  }
  //[end]</pre>

<p><a data-primary="getBodyPixelCoord() function (PBox2D)" data-type="indexterm">&nbsp;</a> <a data-primary="PBox2D helper class" data-secondary="getBodyPixelCoord() function (PBox2D)" data-type="indexterm">&nbsp;</a></p>

<p>But now Box2D manages the object&rsquo;s motion, so we can no longer use our own variables to display the shape. Not to fear! Our <strong klass="">Box</strong> object has a reference to the Box2D body associated with it. So all we need to do is politely ask the body, &ldquo;Pardon me, where are you located?&rdquo; Since this is a task we&rsquo;ll need to do quite often, PBox2D includes a helper function: <strong function="">getBodyPixelCoord()</strong>.</p>

<pre data-code-language="java" data-type="programlisting">
Vec2 pos = box2d.getBodyPixelCoord(body);</pre>

<p>Just knowing the location of a body isn&rsquo;t enough; we also need to know its angle of rotation.</p>

<p><a data-primary="getAngle() function (PBox2D)" data-type="indexterm">&nbsp;</a></p>

<pre data-code-language="java" data-type="programlisting">
float a = body.getAngle();</pre>

<p><a data-primary="rotate() function (PBox2D)" data-type="indexterm">&nbsp;</a> <a data-primary="translate() function (PBox2D)" data-type="indexterm">&nbsp;</a></p>

<p>Once we have the location and angle, it&rsquo;s easy to display the object using <strong function="">translate()</strong> and <strong function="">rotate()</strong>. Note, however, that the Box2D coordinate system considers rotation in the opposite direction from Processing, so we need to multiply the angle by -1.</p>

<figure id="chapter05_figure4"><img alt="Figure 5.4" src="../images/chapter05/ch05_04.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<pre data-code-language="java" data-type="programlisting">
  void display() {
    //[full] We need the Body&rsquo;s location and angle.
    Vec2 pos = box2d.getBodyPixelCoord(body);
    float a = body.getAngle();
    //[end]

    pushMatrix();
    //[full] Using the Vec2 position and float angle to translate and rotate the rectangle
    translate(pos.x,pos.y);
    rotate(-a);
    //[end]
    fill(175);
    stroke(0);
    rectMode(CENTER);
    rect(0,0,w,h);
    popMatrix();
  }</pre>

<p>In case we want to have objects that can be removed from the Box2D world, it&rsquo;s also useful to include a function to destroy a body, such as:</p>

<p><a data-primary="destroyBody() function (PBox2D)" data-type="indexterm">&nbsp;</a></p>

<pre data-code-language="java" data-type="programlisting">
  // This function removes a body from the Box2D world.
  void killBody() {
    box2d.destroyBody(body);
  }</pre>

<div data-type="exercise" id="chapter05_exercise2">
<h5>Exercise 5.2</h5>

<figure class="screenshot"><img alt="ch05 exc02" src="../images/chapter05/ch05_exc02.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<p>In this chapter&rsquo;s code downloads, find the sketch named &ldquo;box2d_exercise.&rdquo; Using the methodology outlined in this chapter, add the necessary code to the main and Box tabs to implement Box2D physics. The result should appear as in the screenshot above. Be more creative in how you render the boxes.</p>
</div>
</section>
</section>

<section data-type="sect1" id="chapter05_section8">
<h1>5.8 Fixed Box2D Objects</h1>

<p><a data-primary="BodyDef type (body element)" data-secondary="STATIC type" data-type="indexterm">&nbsp;</a> <a data-primary="boundaries" data-secondary="fixed" data-type="indexterm">&nbsp;</a> <a data-primary="Box2D" data-secondary="fixed objects in" data-type="indexterm">&nbsp;</a> <a data-primary="static (body type)" data-type="indexterm">&nbsp;</a></p>

<p>In the example we just created, the <strong klass="">Box</strong> objects appear at the mouse location and fall downwards due to Box2D&rsquo;s default gravity force. What if we wanted to install some immovable boundaries in the Box2D world that would block the path of the <strong klass="">Box</strong> objects (as in the illustration below)?</p>

<p>Box2D makes this easy for us by providing a means to lock a body (and any associated shapes) in place. Just set the <strong klass="">BodyDef</strong> object&rsquo;s type to <strong class="var">STATIC</strong>.</p>

<pre data-code-language="java" data-type="programlisting">
 BodyDef bd = new BodyDef();
 // When BodyDef type = STATIC, the
 // Body is locked in place.
 bd.type = BodyType.STATIC;</pre>

<p>We can add this feature to our Boxes example by writing a <strong klass="">Boundary</strong> class and having each boundary create a fixed Box2D body.</p>

<figure class="screenshot"><img alt="ch05 ex02" src="../images/chapter05/ch05_ex02.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<p><strong example="">Example 5.2: Falling boxes hitting boundaries</strong></p>

<pre data-code-language="java" data-type="programlisting">
class Boundary {

  //[full] A boundary is a simple rectangle with x, y, width, and height.
  float x,y;
  float w,h;
  //[end]
  Body b;

  Boundary(float x_,float y_, float w_, float h_) {
    x = x_;
    y = y_;
    w = w_;
    h = h_;

    // Build the Box2D Body and Shape.
    BodyDef bd = new BodyDef();
    bd.position.set(box2d.coordPixelsToWorld(x,y));
    // Make it fixed by setting type to STATIC!
    bd.type = BodyType.STATIC;
    b = box2d.createBody(bd);

    float box2dW = box2d.scalarPixelsToWorld(w/2);
    float box2dH = box2d.scalarPixelsToWorld(h/2);
    PolygonShape ps = new PolygonShape();
    // The PolygonShape is just a box.
    ps.setAsBox(box2dW, box2dH);

    // Using the createFixture() shortcut
    b.createFixture(ps,1);
  }

  // Since we know it can never move, we can just draw it
  // the old-fashioned way, using our original
  // variables. No need to query Box2D.
  void display() {
    fill(0);
    stroke(0);
    rectMode(CENTER);
    rect(x,y,w,h);
  }

}</pre>
</section>

<section data-type="sect1" id="chapter05_section9">
<h1>5.9 A Curvy Boundary</h1>

<p><a data-primary="boundaries" data-secondary="curvy" data-type="indexterm">&nbsp;</a> <a data-primary="ChainShape class" data-type="indexterm">&nbsp;</a></p>

<p>If you want a fixed boundary that is a curved surface (as opposed to a polygon), this can be achieved with the shape <strong klass="">ChainShape</strong>.</p>

<p>The <strong klass="">ChainShape</strong> class is another shape like <strong klass="">PolygonShape</strong> or <strong klass="">CircleShape</strong>, so to include one in our system, we follow the same steps.</p>

<section data-type="sect2" id="_step_1_define_a_body_2">
<h2>Step 1: Define a body.</h2>

<pre data-code-language="java" data-type="programlisting">
// The body does not need a position; the
// EdgeShape will take care of that for us.
// It also does not need a type, as it is STATIC
// by default.
BodyDef bd = new BodyDef();
Body body = box2d.world.createBody(bd);</pre>
</section>

<section data-type="sect2" id="_step_2_define_the_shape">
<h2>Step 2: Define the Shape.</h2>

<pre data-code-language="java" data-type="programlisting">
ChainShape chain = new ChainShape();</pre>
</section>

<section data-type="sect2" id="_step_3_configure_the_shape">
<h2>Step 3: Configure the Shape.</h2>

<p><a data-primary="ChainShape class" data-secondary="configuring" data-type="indexterm">&nbsp;</a></p>

<p>The <strong klass="">ChainShape</strong> object is a series of connected vertices. To create the chain, we must first specify an array of vertices (each as a <strong klass="">Vec2</strong> object). For example, if we wanted a straight line from the left-hand side of our window to the right-hand side, we would just need an array of two vertices: (0,150) and (width,150). (Note that if you want to create a loop where the first vertex connects to the last vertex in a loop, you can use the <strong klass="">ChainLoop</strong> class instead.)</p>

<pre data-code-language="java" data-type="programlisting">
Vec2[] vertices = new Vec2[2];
// Adding a vertex on the right side of window
vertices[0] = box2d.coordPixelsToWorld(0,150);
// Adding a vertex on the left side of window
vertices[1] = box2d.coordPixelsToWorld(width,150);</pre>

<p>To create the chain with the vertices, the array is then passed into a function called <strong function="">createChain()</strong>.</p>

<pre data-code-language="java" data-type="programlisting">
// If you don&rsquo;t want to use the entire array,
// you can specify a value less than length.
chain.createChain(vertices, vertices.length);</pre>

<figure class="screenshot"><img alt="ch05 ex03" src="../images/chapter05/ch05_ex03.png" />
<figcaption>&nbsp;</figcaption>
</figure>
</section>

<section data-type="sect2" id="_step_4_attach_the_shape_to_the_body_with_a_fixture">
<h2>Step 4: Attach the Shape to the body with a Fixture.</h2>

<p>A <strong klass="">Shape</strong> is not part of Box2D unless it is attached to a body. Even if it is a fixed boundary and never moves, it must still be attached. Just as with other shapes, a <strong klass="">ChainShape</strong> object can be given properties like restitution and friction with a <strong klass="">Fixture</strong>.</p>

<pre data-code-language="java" data-type="programlisting">
FixtureDef fd = new FixtureDef();
// A fixture assigned to the ChainShape
fd.shape = chain;
fd.density = 1;
fd.friction = 0.3;
fd.restitution = 0.5;

body.createFixture(fd);</pre>

<p>Now, if we want to include a <strong klass="">ChainShape</strong> object in our sketch, we can follow the same strategy as we did with a fixed boundary. Let&rsquo;s write a class called <strong klass="">Surface</strong>:</p>

<figure class="screenshot"><img alt="ch05 ex04" src="../images/chapter05/ch05_ex04.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<p><strong example="">Example 5.3: ChainShape with three hard-coded vertices</strong></p>

<pre data-code-language="java" data-type="programlisting">
class Surface {
  ArrayList&lt;Vec2&gt; surface;

  Surface() {

    surface = new ArrayList&lt;Vec2&gt;();
    //[full] 3 vertices in pixel coordinates
    surface.add(new Vec2(0, height/2+50));
    surface.add(new Vec2(width/2, height/2+50));
    surface.add(new Vec2(width, height/2));
    //[end]

    ChainShape chain = new ChainShape();

    // Make an array of Vec2 for the ChainShape.
    Vec2[] vertices = new Vec2[surface.size()];


    for (int i = 0; i &lt; vertices.length; i++) {
      //[offset-up] Convert each vertex to Box2D World coordinates.
      vertices[i] = box2d.coordPixelsToWorld(surface.get(i));
    }

    // Create the ChainShape with array of Vec2.
    chain.createChain(vertices, vertices.length);

    //[full] Attach the Shape to the Body.
    BodyDef bd = new BodyDef();
    Body body = box2d.world.createBody(bd);
    body.createFixture(chain, 1);
    //[end]
  }</pre>

<p>Notice how the above class includes an <strong klass="">ArrayList</strong> to store a series of <strong klass="">Vec2</strong> objects. Even though we fully intend to store the coordinates of the chain in the chain shape itself, we are choosing the ease of redundancy and keeping our own list of those points as well. Later, when we go to draw the <strong klass="">Surface</strong> object, we don&rsquo;t have to ask Box2D for the locations of the chain shape&rsquo;s vertices.</p>

<pre data-code-language="java" data-type="programlisting">
  void display() {
    strokeWeight(1);
    stroke(0);
    noFill();
    //[full] Draw the ChainShape as a series of vertices.
    beginShape();
    for (Vec2 v: surface) {
      vertex(v.x,v.y);
    }
    //[end]
    endShape();
  }
}</pre>

<p>What we need in <strong function="">setup()</strong> and <strong function="">draw()</strong> for the <strong klass="">Surface</strong> object is quite simple, given that Box2D takes care of all of the physics for us.</p>

<pre data-code-language="java" data-type="programlisting">
PBox2D box2d;

Surface surface;

void setup() {
  size(500,300);
  box2d = new PBox2D(this);
  box2d.createWorld();

  // Make a Surface object.
  surface = new Surface();
}

void draw() {
  box2d.step();

  background(255);
  // Draw the Surface.
  surface.display();
}</pre>

<div data-type="exercise" id="chapter05_exercise3">
<h5>Exercise 5.3</h5>

<p>Review how we learned to draw a wave pattern in Chapter 3. Create a <strong klass="">ChainShape</strong> object out of a sine wave. Try using <a href="#intro_section6">Perlin noise</a> as well.</p>

<figure class="two-col"><img alt="sine wave" src="../images/chapter05/ch05_exc03a.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<figure class="two-col"><img alt="Perlin noise" src="../images/chapter05/ch05_exc03b.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<figure><img alt="blank" src="../images/blank.png" />
<figcaption>&nbsp;</figcaption>
</figure>
</div>
</section>
</section>

<section data-type="sect1" id="chapter05_section10">
<h1>5.10 Complex Forms</h1>

<p><a data-primary="Box2D" data-secondary="complex forms in" data-type="indexterm">&nbsp;</a></p>

<figure class="half-width-right" id="chapter05_figure5"><img alt="Figure 5.5" src="../images/chapter05/ch05_05.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<p>Now that we&rsquo;ve seen how easy it is to make simple geometric forms in Box2D, let&rsquo;s imagine that you want to have a more complex form, such as a little alien stick figure.</p>

<p>There are two strategies in Box2D for making forms that are more advanced than a basic circle or square. One is to use a <strong klass="">PolygonShape</strong> in a different way. In our previous examples, we used <strong klass="">PolygonShape</strong> to generate a rectangular shape with the <strong function="">setAsBox()</strong> function.</p>

<pre data-code-language="java" data-type="programlisting">
  PolygonShape ps = new PolygonShape();
  ps.setAsBox(box2dW, box2dH);</pre>

<p><a data-primary="PolygonShape class" data-secondary="as list of vectors" data-type="indexterm">&nbsp;</a></p>

<p>This was a good way to start because of the inherent simplicity of working with rectangles. However, a <strong klass="">PolygonShape</strong> object can also be generated from an array of vectors, which allows you to build a completely custom shape as a series of connected vertices. This works very similarly to the <strong klass="">ChainShape</strong> class.</p>

<figure class="screenshot"><img alt="ch05 ex05" src="../images/chapter05/ch05_ex05.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<p><strong example="">Example 5.4: Polygon shapes</strong></p>

<pre data-code-language="java" data-type="programlisting">
Vec2[] vertices = new Vec2[4];	// An array of 4 vectors
vertices[0] = box2d.vectorPixelsToWorld(new Vec2(-15, 25));
vertices[1] = box2d.vectorPixelsToWorld(new Vec2(15, 0));
vertices[2] = box2d.vectorPixelsToWorld(new Vec2(20, -15));
vertices[3] = box2d.vectorPixelsToWorld(new Vec2(-10, -10));

//[full] Making a polygon from that array
PolygonShape ps = new PolygonShape();
ps.set(vertices, vertices.length);
//[end]</pre>

<p>When building your own polygon in Box2D, you must remember two important details.</p>

<figure class="half-width-left" id="chapter05_figure6"><img alt="Figure 5.6" src="../images/chapter05/ch05_06.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<p><a data-primary="Box2D" data-secondary="order of vertices" data-type="indexterm">&nbsp;</a></p>

<ol>
	<li>
	<p><strong>Order of vertices!</strong> If you are thinking in terms of pixels (as above) the vertices should be defined in counterclockwise order. (When they are translated to Box2D World vectors, they will actually be in clockwise order since the vertical axis is flipped.)</p>
	</li>
	<li>
	<p><strong>Convex shapes only!</strong> A concave shape is one where the surface curves inward. Convex is the opposite (see illustration below). Note how in a convex shape every internal angle must be 180 degrees or less. Box2D is not capable of handling collisions for concave shapes. If you need a concave shape, you will have to build one out of multiple convex shapes (more about that in a moment).</p>
	</li>
</ol>

<p><a data-primary="Box2D" data-secondary="concave shapes and" data-type="indexterm">&nbsp;</a></p>

<figure id="chapter05_figure7"><img alt="Figure 5.7: A concave shape can be drawn with multiple convex shapes." src="../images/chapter05/ch05_07.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<p><a data-primary="beginShape() function (Processing)" data-type="indexterm">&nbsp;</a> <a data-primary="endShape() function (Processing)" data-type="indexterm">&nbsp;</a></p>

<p>Now, when it comes time to display the shape in Processing, we can no longer just use <strong function="">rect()</strong> or <strong function="">ellipse()</strong>. Since the shape is built out of custom vertices, we&rsquo;ll want to use Processing&rsquo;s <strong function="">beginShape()</strong>, <strong function="">endShape()</strong>, and <strong function="">vertex()</strong> functions. As we saw with the <strong klass="">ChainShape</strong>, we could choose to store the pixel locations of the vertices in our own <strong klass="">ArrayList</strong> for drawing. However, it&rsquo;s also useful to see how we can ask Box2D to report back to use the vertex locations.</p>

<pre data-code-language="java" data-type="programlisting">
  void display() {
    Vec2 pos = box2d.getBodyPixelCoord(body);
    float a = body.getAngle();

    // First we get the Fixture attached to the body...
    Fixture f = body.getFixtureList();
    // ...then the Shape attached to the Fixture.
    PolygonShape ps = (PolygonShape) f.getShape();

    rectMode(CENTER);
    pushMatrix();
    translate(pos.x,pos.y);
    rotate(-a);
    fill(175);
    stroke(0);
    beginShape();
    //[offset-up] We can loop through that array and convert each vertex from Box2D space to pixels.
    for (int i = 0; i &lt; ps.getVertexCount(); i++) {
      Vec2 v = box2d.vectorWorldToPixels(ps.getVertex(i));
      vertex(v.x,v.y);
    }
    endShape(CLOSE);
    popMatrix();
  }</pre>

<div data-type="exercise" id="chapter05_exercise4">
<h5>Exercise 5.4</h5>

<p>Using the <strong klass="">PolygonShape</strong> class, create your own polygon design (remember, it must be convex). Some possibilities below.</p>

<figure><img alt="ch05 exc04" src="../images/chapter05/ch05_exc04.png" />
<figcaption>&nbsp;</figcaption>
</figure>
</div>

<p><a data-primary="body (Box2D element)" data-secondary="multiple shapes and" data-type="indexterm">&nbsp;</a></p>

<p>A polygon shape will get us pretty far in Box2D. Nevertheless, the convex shape requirement will severely limit the range of possibilities. The good news is that we can completely eliminate this restriction by creating a single Box2D body out of multiple shapes! Let&rsquo;s return to our little alien creature and simplify the shape to be a thin rectangle with a circle on top.</p>

<p>How can we build a single body with two shapes? Let&rsquo;s first review how we built a single body with one shape.</p>

<p><em>Step 1: Define the body.</em><br />
<em>Step 2: Create the body.</em><br />
<strong><em>Step 3: Define the shape.</em></strong><br />
<strong><em>Step 4: Attach the shape to the body.</em></strong><br />
<em>Step 5: Finalize the body&rsquo;s mass.</em></p>

<p>Attaching more than one shape to a body is as simple as repeating steps 3 and 4 over and over again.</p>

<p><strong><em>Step 3a: Define shape 1.</em></strong><br />
<strong><em>Step 4a: Attach shape 1 to the body.</em></strong><br />
<strong><em>Step 3b: Define shape 2.</em></strong><br />
<strong><em>Step 4b: Attach shape 2 to the body.</em></strong><br />
etc. etc. etc.</p>

<p>Let&rsquo;s see what this would look like with actual Box2D code.</p>

<pre data-code-language="java" data-type="programlisting">
//[full] Making the body
BodyDef bd = new BodyDef();
bd.type = BodyType.DYNAMIC;
bd.position.set(box2d.coordPixelsToWorld(center));
body = box2d.createBody(bd);
//[end]

//[full] Making shape 1 (the rectangle)
PolygonShape ps = new PolygonShape();
float box2dW = box2d.scalarPixelsToWorld(w/2);
float box2dH = box2d.scalarPixelsToWorld(h/2);
sd.setAsBox(box2dW, box2dH);
//[end]

//[full] Making shape 2 (the circle)
CircleShape cs = new CircleShape();
cs.m_radius = box2d.scalarPixelsToWorld(r);
//[end]

//[full] Attach both shapes with a fixture.
body.createFixture(ps,1.0);
body.createFixture(cs, 1.0);
//[end]</pre>

<p>The above looks pretty good, but sadly, if we run it, we&rsquo;ll get the following result:</p>

<figure id="chapter05_figure8"><img alt="Figure 5.8" src="../images/chapter05/ch05_08.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<p>When you attach a shape to a body, by default, the center of the shape will be located at the center of the body. But in our case, if we take the center of the rectangle to be the center of the body, we want the center of the circle to be offset along the y-axis from the body&rsquo;s center.</p>

<figure id="chapter05_figure9"><img alt="Figure 5.9" src="../images/chapter05/ch05_09.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<p><a data-primary="m_p variable (Vec2 class)" data-type="indexterm">&nbsp;</a> <a data-primary="Shape (Box2D element)" data-secondary="local position for" data-type="indexterm">&nbsp;</a></p>

<p>This is achieved by using the local position of a shape, accessed via a <strong klass="">Vec2</strong> variable called <strong class="var">m_p</strong>.</p>

<pre data-code-language="java" data-type="programlisting">
// Our offset in pixels
Vec2 offset = new Vec2(0,-h/2);
// Converting the vector to Box2D world
offset = box2d.vectorPixelsToWorld(offset);
// Setting the local position of the circle
circle.m_p.set(offset.x,offset.y);</pre>

<p>Then, when we go to draw the body, we use both <strong function="">rect()</strong> and <strong function="">ellipse()</strong> with the circle offset the same way.</p>

<figure class="screenshot"><img alt="ch05 ex06" src="../images/chapter05/ch05_ex06.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<p><strong example="">Example 5.5: Multiple shapes on one body</strong></p>

<pre data-code-language="java" data-type="programlisting">
  void display() {
    Vec2 pos = box2d.getBodyPixelCoord(body);
    float a = body.getAngle();

    rectMode(CENTER);
    pushMatrix();
    translate(pos.x,pos.y);
    rotate(-a);
    fill(175);
    stroke(0);
    // First the rectangle at (0,0)
    rect(0,0,w,h);
    // Then the ellipse offset at (0,-h/2)
    ellipse(0,-h/2,r*2,r*2);
    popMatrix();
  }</pre>

<p>Finishing off this section, I want to stress the following: the stuff you draw in your Processing window doesn&rsquo;t magically experience physics simply because we created some Box2D bodies and shapes. These examples work because we very carefully matched how we draw our elements with how we defined the bodies and shapes we put into the Box2D world. If you accidentally draw your shape differently, you won&rsquo;t get an error, not from Processing or from Box2D. However, your sketch will look odd and the physics won&rsquo;t work correctly. For example, what if we had written:</p>

<pre data-code-language="java" data-type="programlisting">
Vec2 offset = new Vec2(0,-h/2);</pre>

<p>when we created the shape, but:</p>

<pre data-code-language="java" data-type="programlisting">
ellipse(0,h/2,r*2,r*2);</pre>

<p>when it came time to display the shape?</p>

<figure class="screenshot"><img alt="ch05 ex07" src="../images/chapter05/ch05_ex07.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<p>The results would look like the image above, where clearly, the collisions are not functioning as expected. This is not because the physics is broken; it&rsquo;s because we did not communicate properly with Box2D, either when we put stuff in the magic world or queried the world for locations.</p>

<div data-type="exercise" id="chapter05_exercise5">
<h5>Exercise 5.5</h5>

<p>Make your own little alien being using multiple shapes attached to a single body. Try using more than one polygon to make a concave shape. Remember, you aren&rsquo;t limited to using the shape drawing functions in Processing; you can use images, colors, add hair with lines, etc. Think of the Box2D shapes only as skeletons for your creative and fantastical design!</p>
</div>
</section>

<section data-type="sect1" id="chapter05_section11">
<h1>5.11 Feeling Attached&mdash;Box2D Joints</h1>

<p><a data-primary="joint (Box2D element)" data-type="indexterm">&nbsp;</a></p>

<figure class="half-width-right" id="chapter05_figure10"><img alt="Figure 5.10" src="../images/chapter05/ch05_10.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<p>Box2D joints allow you to connect one body to another, enabling more advanced simulations of swinging pendulums, elastic bridges, squishy characters, wheels spinning on an axle, etc. There are many different kinds of Box2D joints. In this chapter we&rsquo;re going to look at three: distance joints, revolute joints, and &ldquo;mouse&rdquo; joints.</p>

<p><a data-primary="distance joints" data-type="indexterm">&nbsp;</a> <a data-primary="joint (Box2D element)" data-secondary="distance" data-type="indexterm">&nbsp;</a></p>

<p>Let&rsquo;s begin with a distance joint, a joint that connects two bodies with a fixed length. The joint is attached to each body at a specified anchor point (a point relative to the body&rsquo;s center). For any Box2D joint, we need to follow these steps. This, of course, is similar to the methodology we used to build bodies and shapes, with some quirks.</p>

<p><strong><em>Step 1. Make sure you have two bodies ready to go.</em></strong><br />
<strong><em>Step 2. Define the joint.</em></strong><br />
<strong><em>Step 3. Configure the joint&rsquo;s properties (What are the bodies? Where are the anchors? What is its rest length? Is it elastic or rigid?)</em></strong><br />
<strong><em>Step 4. Create the joint.</em></strong></p>

<p>Let&rsquo;s assume we have two <strong klass="">Particle</strong> objects that each store a reference to a Box2D <strong klass="">Body</strong> object. We&rsquo;ll call them particles <strong class="var">p1</strong> and <strong class="var">p2</strong>.</p>

<pre data-code-language="java" data-type="programlisting">
Particle p1 = new Particle();
Particle p2 = new Particle();</pre>

<p><a data-primary="DistanceJointDef (Box2D joint type)" data-type="indexterm">&nbsp;</a></p>

<p>OK, onto Step 2. Let&rsquo;s define the joint.</p>

<pre data-code-language="java" data-type="programlisting">
DistanceJointDef djd = new DistanceJointDef();</pre>

<p>Easy, right? Now it&rsquo;s time to configure the joint. First we tell the joint which two bodies it connects:</p>

<pre data-code-language="java" data-type="programlisting">
djd.bodyA = p1.body;
djd.bodyB = p2.body;</pre>

<p><a data-primary="rest length (Box2D joint element)" data-type="indexterm">&nbsp;</a></p>

<p>Then we set up a rest length. Remember, if our rest length is in pixels, we need to convert it!</p>

<pre data-code-language="java" data-type="programlisting">
djd.length = box2d.scalarPixelsToWorld(10);</pre>

<p><a data-primary="dampingRatio setting (Box2D joint element)" data-type="indexterm">&nbsp;</a> <a data-primary="frequencyHz setting (Box2D joint element)" data-type="indexterm">&nbsp;</a></p>

<p>A distance joint also includes two optional settings that can make the joint soft, like a spring connection: <strong class="var">frequencyHz</strong> and <strong class="var">dampingRatio</strong>.</p>

<pre data-code-language="java" data-type="programlisting">
  // Measured in Hz, like the frequency of harmonic
  // oscillation; try values between 1 and 5.
  djd.frequencyHz  = ___;
  // Dampens the spring; typically a number between 0 and 1.
  djd.dampingRatio = ___;</pre>

<p>Finally, we create the joint.</p>

<pre data-code-language="java" data-type="programlisting">
DistanceJoint dj = (DistanceJoint) box2d.world.createJoint(djd);</pre>

<p>Box2D won&rsquo;t keep track of what kind of joint we are making, so we have to cast it as a <strong klass="">DistanceJoint</strong> upon creation.</p>

<p>We can create Box2D joints anywhere in our Processing sketch. Here&rsquo;s an example of how we might write a class to describe two Box2D bodies connected with a single joint.</p>

<figure class="screenshot"><img alt="ch05 ex08" src="../images/chapter05/ch05_ex08.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<p><strong example="">Example 5.6: DistanceJoint</strong></p>

<pre data-code-language="java" data-type="programlisting">
class Pair {

  //[full] Two objects that each have a Box2D body
  Particle p1;
  Particle p2;
  //[end]
  // Arbitrary rest length
  float len = 32;

  Pair(float x, float y) {

    //[full]
    // Problems can result if the bodies are initialized at the same location.

    p1 = new Particle(x,y);
    p2 = new Particle(x+random(-1,1),y+random(-1,1));
    //[end]

    // Making the joint!
    DistanceJointDef djd = new DistanceJointDef();
    djd.bodyA = p1.body;
    djd.bodyB = p2.body;
    djd.length = box2d.scalarPixelsToWorld(len);
    djd.frequencyHz = 0;  // Try a value less than 5
    djd.dampingRatio = 0; // Ranges between 0 and 1

    //[offset-down] Make the joint.  Note that we aren't storing a reference to the joint anywhere! We might need to someday, but for now it's OK.
    DistanceJoint dj = (DistanceJoint) box2d.world.createJoint(djd);
  }

  void display() {
    Vec2 pos1 = box2d.getBodyPixelCoord(p1.body);
    Vec2 pos2 = box2d.getBodyPixelCoord(p2.body);
    stroke(0);
    line(pos1.x,pos1.y,pos2.x,pos2.y);

    p1.display();
    p2.display();
  }
}</pre>

<div data-type="exercise" id="chapter05_exercise6">
<h5>Exercise 5.6</h5>

<p>Create a simulation of a bridge by using distance joints to connect a sequence of circles (or rectangles) as illustrated to the right. Assign a density of zero to lock the endpoints in place. Experiment with different values to make the bridge more or less &ldquo;springy.&rdquo; It should also be noted that the joints themselves have no physical geometry, so in order for your bridge not to have holes, spacing between the nodes will be important.</p>

<figure class="screenshot"><img alt="ch05 exc06" src="../images/chapter05/ch05_exc06.png" />
<figcaption>&nbsp;</figcaption>
</figure>
</div>

<figure class="half-width-right" id="chapter05_figure11"><img alt="Figure 5.11" src="../images/chapter05/ch05_11.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<p><a data-primary="joint (Box2D element)" data-secondary="revolute type" data-type="indexterm">&nbsp;</a> <a data-primary="revolute joint type (Box2D)" data-type="indexterm">&nbsp;</a></p>

<p>Another joint you can create in Box2D is a <em>revolute joint</em>. A revolute joint connects two Box2D bodies at a common anchor point, which can also be referred to as a &ldquo;hinge.&rdquo; The joint has an &ldquo;angle&rdquo; that describes the relative rotation of each body. To use a revolute joint, we follow the same steps we did with the distance joint.</p>

<section data-type="sect2" id="_step_1_make_sure_you_have_two_bodies_ready_to_go">
<h2>Step 1: Make sure you have two bodies ready to go.</h2>

<p>Let&rsquo;s assume we have two <strong klass="">Box</strong> objects, each of which stores a reference to a Box2D body.</p>

<pre data-code-language="java" data-type="programlisting">
Box box1 = new Box();
Box box2 = new Box();</pre>
</section>

<section data-type="sect2" id="_step_2_define_the_joint">
<h2>Step 2: Define the joint.</h2>

<p><a data-primary="RevoluteJointDef object (Box2D joint element)" data-type="indexterm">&nbsp;</a></p>

<p>Now we want a <strong klass="">RevoluteJointDef</strong> object.</p>

<pre data-code-language="java" data-type="programlisting">
RevoluteJointDef rjd = new RevoluteJointDef();</pre>
</section>

<section data-type="sect2" id="_step_3_configure_the_joint_s_properties">
<h2>Step 3: Configure the joint&rsquo;s properties.</h2>

<p><a data-primary="revolute joint type (Box2D)" data-secondary="properties" data-tertiary="configuring" data-type="indexterm">&nbsp;</a></p>

<p>The most important properties of a revolute joint are the two bodies it connects as well as their mutual anchor point (i.e. where they are connected). They are set with the function <strong function="">initialize()</strong>.</p>

<pre data-code-language="java" data-type="programlisting">
rjd.initialize(box1.body, box2.body, box1.body.getWorldCenter());</pre>

<p>Notice how the first two arguments specify the bodies and the second point specifies the anchor, which in this case is located at the center of the first body.</p>

<p>An exciting feature of a <strong klass="">RevoluteJoint</strong> object is that you can motorize it so it spins autonomously. For example:</p>

<pre data-code-language="java" data-type="programlisting">
// Turn on the motor.
rjd.enableMotor = true;
 // How fast is the motor?
rjd.motorSpeed = PI*2;
// How powerful is the motor?
rjd.maxMotorTorque = 1000.0;</pre>

<p>The motor can be enabled and disabled while the program is running.</p>

<p>Finally, the ability for a revolute joint to spin can be constrained between two angles. (By default, it can rotate a full 360 degrees, or <strong class="var">TWO_PI</strong> radians.)</p>

<pre data-code-language="java" data-type="programlisting">
rjd.enableLimit = true;
rjd.lowerAngle = -PI/8;
rjd.upperAngle = PI/8;</pre>
</section>

<section data-type="sect2" id="_step_4_create_the_joint">
<h2>Step 4: Create the joint.</h2>

<pre data-code-language="java" data-type="programlisting">
RevoluteJoint joint = (RevoluteJoint) box2d.world.createJoint(rjd);</pre>

<p>Let&rsquo;s take a look at all of these steps together in a class called <strong klass="">Windmill</strong>, which connects two boxes with a revolute joint. In this case, <strong class="var">box1</strong> has a density of zero, so only <strong class="var">box2</strong> spins around a fixed point.</p>

<figure class="screenshot"><img alt="ch05 ex09" src="../images/chapter05/ch05_ex09.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<p><strong example="">Example 5.7: Spinning Windmill</strong></p>

<pre data-code-language="java" data-type="programlisting">
class Windmill {

  // Our &ldquo;Windmill&rdquo; is two boxes and one joint.
  RevoluteJoint joint;
  Box box1;
  Box box2;

  Windmill(float x, float y) {

    //[full] In this example, the Box class expects a boolean argument that will be used to determine if the Box is fixed or not.  See website for the Box class code.
    box1 = new Box(x,y,120,10,false);
    box2 = new Box(x,y,10,40,true);


    //[end]

    RevoluteJointDef rjd = new RevoluteJointDef();
    //[offset-down] The joint connects two bodies and is anchored at the center of the first body.
    rjd.initialize(box1.body, box2.body, box1.body.getWorldCenter());



    // A motor!
    rjd.motorSpeed = PI*2;
    rjd.maxMotorTorque = 1000.0;
    rjd.enableMotor = true;

    //[offset-down] Create the Joint.
    joint = (RevoluteJoint) box2d.world.createJoint(rjd);
  }

  //[full] Turning the motor on or off
  void toggleMotor() {
    boolean motorstatus = joint.isMotorEnabled();
    joint.enableMotor(!motorstatus);
  }
  //[end]

  void display() {
    box1.display();
    box2.display();
  }
}</pre>

<div data-type="exercise" id="chapter05_exercise7">
<h5>Exercise 5.7</h5>

<figure class="half-width-right"><img alt="ch05 exc07" src="../images/chapter05/ch05_exc07.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<p>Use a revolute joint for the wheels of a car. Use motors so that the car drives autonomously. Try using a chain shape for the road&rsquo;s surface.</p>

<figure><img alt="blank" src="../images/blank.png" />
<figcaption>&nbsp;</figcaption>
</figure>
</div>

<p><a data-primary="joint (Box2D element)" data-secondary="mouse type" data-type="indexterm">&nbsp;</a> <a data-primary="mouse joint (Box2D Joint type)" data-type="indexterm">&nbsp;</a></p>

<p>The last joint we&rsquo;ll look at is a mouse joint. A mouse joint is typically used for moving a body with the mouse. However, it can also be used to drag an object around the screen according to some arbitrary <em>x</em> and <em>y</em>. The joint functions by pulling the body towards a &ldquo;target&rdquo; position.</p>

<p><a data-primary="mouse joint (Box2D joint type)" data-secondary="setTransform() function" data-type="indexterm">&nbsp;</a> <a data-primary="setTransform() function (Box2D)" data-type="indexterm">&nbsp;</a></p>

<p>Before we look at the <strong klass="">MouseJoint</strong> object itself, let&rsquo;s ask ourselves why we even need it in the first place. If you look at the Box2D documentation, there is a function called <strong function="">setTransform()</strong> that specifically &ldquo;sets the position of the body&rsquo;s origin and rotation (radians).&rdquo; If a body has a position, can&rsquo;t we just assign the body&rsquo;s position to the mouse?</p>

<pre data-code-language="java" data-type="programlisting">
Vec2 mouse = box2d.screenToWorld(x,y);
body.setTransform(mouse,0);</pre>

<p>While this will in fact move the body, it will also have the unfortunate result of breaking the physics. Let&rsquo;s imagine you built a teleportation machine that allows you to teleport from your bedroom to your kitchen (good for late-night snacking). Now, go ahead and rewrite Newton&rsquo;s laws of motion to account for the possibility of teleportation. Not so easy, right? Box2D has the same problem. If you manually assign the location of an body, it&rsquo;s like saying &ldquo;teleport that body&rdquo; and Box2D no longer knows how to compute the physics properly. However, Box2D does allow you to tie a rope to yourself and get a friend of yours to stand in the kitchen and drag you there. This is what the <strong klass="">MouseJoint</strong> does. It&rsquo;s like a string you attach to a body and pull towards a target.</p>

<p>Let&rsquo;s look at making this joint, assuming we have a <strong klass="">Box</strong> object called <strong class="var">box</strong>. This code will look identical to our distance joint with one small difference.</p>

<pre data-code-language="java" data-type="programlisting">
// Just like before, define the Joint.
MouseJointDef md = new MouseJointDef();

// Whoa, this is new!
md.bodyA = box2d.getGroundBody(); //[bold]
// Attach the Box body.
md.bodyB = box.body;

// Set properties.
md.maxForce = 5000.0;
md.frequencyHz = 5.0;
md.dampingRatio = 0.9;

// Create the joint.
MouseJoint mouseJoint = (MouseJoint) box2d.world.createJoint(md);.</pre>

<p><a data-primary="getGroundBody() function (Box2D joint element)" data-type="indexterm">&nbsp;</a></p>

<p>So, what&rsquo;s this line of code all about?</p>

<pre data-code-language="java" data-type="programlisting">
md.bodyA = box2d.getGroundBody(); //[bold]</pre>

<p>Well, as we&rsquo;ve stated, a joint is a connection between <em>two</em> bodies. With a mouse joint, we&rsquo;re saying that the second body is, well, the ground. Hmm. What the heck is the <em>ground</em> in Box2D? One way to imagine it is to think of the screen as the ground. What we&rsquo;re doing is making a joint that connects a rectangle drawn on the window with the Processing window itself. And the point in the window to which the connection is tied is a moving target.</p>

<p>Once we have a mouse joint, we&rsquo;ll want to update the target location continually while the sketch is running.</p>

<pre data-code-language="java" data-type="programlisting">
Vec2 mouseWorld = box2d.coordPixelsToWorld(mouseX,mouseY);
mouseJoint.setTarget(mouseWorld);</pre>

<p>To make this work in an actual Processing sketch, we&rsquo;ll want to have the following:</p>

<ol>
	<li>
	<p><strong><em>Box class</em></strong><code>&mdash;</code>An object that references a Box2D body.</p>
	</li>
	<li>
	<p><strong><em>Spring class</em></strong><code>&mdash;</code>An object that manages the mouse joint that drags the <strong klass="">Box</strong> object around.</p>
	</li>
	<li>
	<p><strong><em>Main tab</em></strong><code>&mdash;</code>Whenever <strong function="">mousePressed()</strong> is called, the mouse joint is created; whenever <strong function="">mouseReleased()</strong> is called, the mouse joint is destroyed. This allows us to interact with a body only when the mouse is pressed.</p>
	</li>
</ol>

<p>Let&rsquo;s take a look at the main tab. You can find the rest of the code for the <strong klass="">Box</strong> and <strong klass="">Spring</strong> classes via the book website.</p>

<figure class="screenshot"><img alt="ch05 ex10" src="../images/chapter05/ch05_ex10.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<p><strong example="">Example 5.8: MouseJoint demonstration</strong></p>

<pre data-code-language="java" data-type="programlisting">
PBox2D box2d;

// One Box
Box box;
// Object to manage MouseJoint
Spring spring;

void setup() {
  size(400,300);
  box2d = new PBox2D(this);
  box2d.createWorld();

  box = new Box(width/2,height/2);
  // The MouseJoint is really null until we click the mouse.
  spring = new Spring();
}

void mousePressed() {
  // Was the mouse clicked inside the Box?
  if (box.contains(mouseX, mouseY)) {
    // If so, attach the MouseJoint.
    spring.bind(mouseX,mouseY,box);
  }
}

void mouseReleased() {
  // When the mouse is released, we&rsquo;re done with the MouseJoint.
  spring.destroy();
}

void draw() {
  background(255);

  box2d.step();

  // We must always update the MouseJoint&rsquo;s target.
  spring.update(mouseX,mouseY);

  box.display();
  spring.display();
}</pre>

<div data-type="exercise" id="chapter05_exercise8">
<h5>Exercise 5.8</h5>

<p>Use a mouse joint to move a Box2D body around the screen according to an algorithm or input other than the mouse. For example, assign it a location according to Perlin noise or key presses. Or build your own controller using an <a href="http://www.arduino.cc/">Arduino</a>.</p>
</div>

<p><a data-primary="kinematic (body type)" data-secondary="MouseJoints and" data-type="indexterm">&nbsp;</a></p>

<p>It&rsquo;s worth noting that while the technique for dragging an object around using a <strong klass="">MouseJoint</strong> is useful, Box2D also allows a body to have a <strong class="var">KINEMATIC</strong> type.</p>

<pre data-code-language="java" data-type="programlisting">
BodyDef bd = new BodyDef();
// Setting the body type to Kinematic
bd.type = BodyType.KINEMATIC;</pre>

<figure class="half-width-right" id="chapter05_figure12"><img alt="Figure 5.12" src="../images/chapter05/ch05_12.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<p>Kinematic bodies can be controlled by the user by setting their velocity directly. For example, let&rsquo;s say you want an object to follow a target (like your mouse). You could create a vector that points from a body&rsquo;s location to a target.</p>

<pre data-code-language="java" data-type="programlisting">
Vec2 pos = body.getWorldCenter();
Vec2 target = box2d.coordPixelsToWorld(mouseX,mouseY);
// A vector pointing from the body position to the Mouse
Vec2 v = target.sub(pos);</pre>

<p>Once you have that vector, you could assign it to the body&rsquo;s velocity so that it moves to the target.</p>

<pre data-code-language="java" data-type="programlisting">
// Assigning a body&rsquo;s velocity directly, overriding physics!
body.setLinearVelocity(v);</pre>

<p>You can also do the same with angular velocity (or leave it alone and allow the physics to take over).</p>

<p>It is important to note that kinematic bodies do not collide with other kinematic or static bodies. In these cases, the mouse joint strategy is preferable.</p>

<div data-type="exercise" id="chapter05_exercise9">
<h5>Exercise 5.9</h5>

<p>Redo Exercise 5.8, but use a kinematic body instead.</p>
</div>
</section>
</section>

<section data-type="sect1" id="chapter05_section12">
<h1>5.12 Bringing It All Back Home to Forces</h1>

<p>In Chapter 2, we spent a lot of time thinking about building environments with multiple forces. An object might respond to gravitational attraction, wind, air resistance, etc. Clearly there are forces at work in Box2D as we watch rectangles and circles spin and fly around the screen. But so far, we&rsquo;ve only had the ability to manipulate a single global force&mdash;gravity.</p>

<pre data-code-language="java" data-type="programlisting">
  box2d = new PBox2D(this);
  box2d.createWorld();
  // Setting the global gravity force
  box2d.setGravity(0, -20);</pre>

<p><a data-primary="applyForce() function (Box2D)" data-type="indexterm">&nbsp;</a> <a data-primary="forces" data-secondary="applyForce() function" data-type="indexterm">&nbsp;</a></p>

<p>If we want to use any of our Chapter 2 techniques with Box2D, we need look no further than our trusty <strong function="">applyForce()</strong> function. In our <strong klass="">Mover</strong> class we wrote a function called <strong function="">applyForce()</strong>, which received a vector, divided it by mass, and accumulated it into the mover&rsquo;s acceleration. With Box2D, the same function exists, but we don&rsquo;t need to write it ourselves. Instead, we can call the Box2D body&rsquo;s <strong function="">applyForce()</strong> function!</p>

<pre data-code-language="java" data-type="programlisting">
class Box {
  Body body;

  void applyForce(Vec2 force) {
    Vec2 pos = body.getWorldCenter();
    // Calling the Body's applyForce() function
    body.applyForce(force, pos);
  }
}</pre>

<p>Here we are receiving a force vector and passing it along to the Box2D <strong klass="">Body</strong> object. The key difference is that Box2D is a more sophisticated engine than our examples from Chapter 2. Our earlier forces examples assumed that the force was always applied at the mover&rsquo;s center. Here we get to specify exactly where on the body the force is applied. In the above code, we&rsquo;re just applying it to the center by asking the body for its center, but this could be adjusted.</p>

<p>Let&rsquo;s say we wanted to use a gravitational attraction force. Remember the code we wrote back in Chapter 2 in our <strong klass="">Attractor</strong> class?</p>

<pre data-code-language="java" data-type="programlisting">
PVector attract(Mover m) {
  PVector force = PVector.sub(location,m.location);
  float distance = force.mag();
  distance = constrain(distance,5.0,25.0);
  force.normalize();
  float strength = (g * mass * m.mass) / (distance * distance);
  force.mult(strength);
  return force;
}</pre>

<p>We can rewrite the exact same function using <strong klass="">Vec2</strong> instead and use it in a Box2D example. Note how for our force calculation we can stay completely within the Box2D coordinate system and never think about pixels.</p>

<pre data-code-language="java" data-type="programlisting">
Vec2 attract(Mover m) {
  // We have to ask Box2D for the locations first!
  Vec2 pos = body.getWorldCenter();
  Vec2 moverPos = m.body.getWorldCenter();
  Vec2 force = pos.sub(moverPos);
  float distance = force.length();
  distance = constrain(distance,1,5);
  force.normalize();
  float strength = (G * 1 * m.body.m_mass) / (distance * distance);
  // Remember, it&rsquo;s mulLocal() for Vec2.
  force.mulLocal(strength);
  return force;
}</pre>

<div data-type="exercise" id="chapter05_exercise10">
<h5>Exercise 5.10</h5>

<p>Take any example you made previously using a force calculation and bring that force calculation into Box2D.</p>

<figure class="screenshot"><img alt="ch05 exc10" src="../images/chapter05/ch05_exc10.png" />
<figcaption>&nbsp;</figcaption>
</figure>
</div>
</section>

<section data-type="sect1" id="chapter05_section13">
<h1>5.13 Collision Events</h1>

<p><a data-primary="collisions" data-secondary="Box2D and" data-type="indexterm">&nbsp;</a></p>

<p>Now we&rsquo;ve seen a survey of what can be done with Box2D. Since this book is not called &ldquo;The Nature of Box2D,&rdquo; it&rsquo;s not my intention to cover every single possible feature of the Box2D engine. But hopefully by looking at the basics of building bodies, shapes, and joints, when it comes time to use an aspect of Box2D that we haven&rsquo;t covered, the skills we&rsquo;ve gained here will make that process considerably less painful. There is one more feature of Box2D, however, that I do think is worth covering.</p>

<p>Let&rsquo;s ask a question you&rsquo;ve likely been wondering about:</p>

<p><em>What if I want something to happen when two Box2D bodies collide? I mean, don&rsquo;t get me wrong&mdash;I&rsquo;m thrilled that Box2D is handling all of the collisions for me. But if it takes care of everything for me, how am I supposed to know when things are happening?</em></p>

<p>Your first thoughts when considering an event during which two objects collide might be as follows: Well, if I know all the bodies in the system, and I know where they are all located, then I can just start comparing the locations, see which ones are intersecting, and determine that they&rsquo;ve collided. That&rsquo;s a nice thought, but hello??!? The whole point of using Box2D is that Box2D will take care of that for us. If we are going to do the geometry to test for intersection ourselves, then all we&rsquo;re doing is re-implementing Box2D.</p>

<p><a data-primary="ContactListener class (JBox2D)" data-type="indexterm">&nbsp;</a> <a data-primary="interfaces" data-type="indexterm">&nbsp;</a> <a data-primary="JBox2D" data-secondary="ContactListener class" data-type="indexterm">&nbsp;</a></p>

<p>Of course, Box2D has thought of this problem before. It&rsquo;s a pretty common one. After all, if you intend to make a bajillion dollars selling some game called Angry Birds, you better well make something happen when an ill-tempered pigeon smashes into a cardboard box. Box2D alerts you to moments of collision with something called an &ldquo;interface.&rdquo; It&rsquo;s worth learning about interfaces, an advanced feature of object-oriented programming. You can take a look at the <a href="http://download.oracle.com/javase/tutorial/java/concepts/interface.html">Java Interface Tutorial</a> as well as the JBox2D <strong klass="">ContactListener</strong> class. (I have also included an example on the website that demonstrates using the interface directly.)</p>

<p><a data-primary="beginContact() function (PBox2D)" data-type="indexterm">&nbsp;</a> <a data-primary="collisions" data-secondary="beginContact() function (PBox2D)" data-type="indexterm">&nbsp;</a></p>

<p>If you are using PBox2D, as we are here, you don&rsquo;t need to implement your own interface. Detecting collision events is done through a callback function. Much like <strong function="">mousePressed()</strong> is triggered when the mouse is pressed, <strong function="">beginContact()</strong> is triggered when two shapes collide.</p>

<pre data-code-language="java" data-type="programlisting">
// The mousePressed event with which we are comfortable.
void mousePressed() {
  println(&quot;The mouse was pressed!&quot;);
}

// What our &quot;beginContact&quot; event looks like.
void beginContact(Contact cp) {
  println(&quot;Something collided in the Box2D World!&quot;);
}</pre>

<p>Before the above will work, you must first let PBox2D know you intend to listen for collisions. (This allows the library to reduce overhead by default; it won&rsquo;t bother listening if it doesn&rsquo;t have to.)</p>

<pre data-code-language="java" data-type="programlisting">
void setup() {
  box2d = new PBox2D(this);
  box2d.createWorld();
  // Add this line if you want to listen for collisions.
  box2d.listenForCollisions();
}</pre>

<p>There are four collision event callbacks.</p>

<p><a data-primary="endContact() function (PBox2D)" data-type="indexterm">&nbsp;</a> <a data-primary="postSolve() function (PBox2D)" data-type="indexterm">&nbsp;</a> <a data-primary="preSolve() function (PBox2D)" data-type="indexterm">&nbsp;</a></p>

<ol>
	<li>
	<p><strong function="">beginContact()</strong> &mdash;Triggered whenever two shapes first come into contact with each other.</p>
	</li>
	<li>
	<p><strong function="">endContact()</strong> &mdash;Triggered over and over again as long as shapes continue to be in contact.</p>
	</li>
	<li>
	<p><strong function="">preSolve()</strong> &mdash;Triggered before Box2D solves the outcome of the collision, i.e. before <strong function="">beginContact()</strong>. It can be used to disable a collision if necessary.</p>
	</li>
	<li>
	<p><strong function="">postSolve()</strong> &mdash;Triggered after the outcome of the collision is solved. It allows you to gather information about that &ldquo;solution&rdquo; (known as an &ldquo;impulse&rdquo;).</p>
	</li>
</ol>

<p>The details behind <strong function="">preSolve()</strong> and <strong function="">postSolve()</strong> are beyond the scope of this book; however, we are going to take a close look at <strong function="">beginContact()</strong>, which will cover the majority of conventional cases in which you want to trigger an action when a collision occurs. <strong function="">endContact()</strong> works identically to <strong function="">beginContact()</strong>, the only difference being that it occurs the moment bodies separate.</p>

<p><strong function="">beginContact()</strong> is written as follows:</p>

<pre data-code-language="java" data-type="programlisting">
void beginContact(Contact cp) {

}</pre>

<p><a data-primary="Contact objects (PBox2D)" data-type="indexterm">&nbsp;</a></p>

<p>Notice that the function above includes an argument of type <strong klass="">Contact</strong>. A <strong klass="">Contact</strong> object includes all the data associated with a collision&mdash;the geometry and the forces. Let&rsquo;s say we have a Processing sketch with <strong klass="">Particle</strong> objects that store a reference to a Box2D body. Here is the process we are going to follow.</p>

<section data-type="sect2" id="_step_1_contact_could_you_tell_me_what_two_things_collided">
<h2>Step 1: Contact, could you tell me what two things collided?</h2>

<p>Now, what has collided here? Is it the bodies? The shapes? The fixtures? Box2D detects collisions between shapes; after all, these are the entities that have geometry. However, because shapes are attached to bodies with fixtures, what we really want to ask Box2D is: &ldquo;Could you tell me which two fixtures collided?&rdquo;</p>

<pre data-code-language="java" data-type="programlisting">
//[full] The contact stores the fixtures as A and B.
Fixture f1 = cp.getFixtureA();
Fixture f2 = cp.getFixtureB();
//[end]</pre>
</section>

<section data-type="sect2" id="_step_2_fixtures_could_you_tell_me_which_body_you_are_attached_to">
<h2>Step 2: Fixtures, could you tell me which body you are attached to?</h2>

<pre data-code-language="java" data-type="programlisting">
//[full] getBody() gives us the body to which the Fixture is attached.
Body b1 = f1.getBody();
Body b2 = f2.getBody();
//[end]</pre>
</section>

<section data-type="sect2" id="_step_3_bodies_could_you_tell_me_which_particles_you_are_associated_with">
<h2>Step 3: Bodies, could you tell me which Particles you are associated with?</h2>

<p>OK, this is the harder part. After all, Box2D doesn&rsquo;t know anything about our code. Sure, it is doing all sorts of stuff to keep track of the relationships between shapes and bodies and joints, but it&rsquo;s up to us to manage our own objects and their associations with Box2D elements. Luckily for us, Box2D provides a function that allows us to attach our Processing object (a <strong klass="">Particle</strong>) to a Box2D body via the <strong function="">setUserData()</strong> and <strong function="">getUserData()</strong> methods.</p>

<p>Let&rsquo;s take a look at the constructor in our <strong klass="">Particle</strong> class where the body is made. We are expanding our body-making procedure by one line of code, noted below.</p>

<pre data-code-language="java" data-type="programlisting">
class Particle {
  Body body;

  Particle(float x, float y, float r) {
    BodyDef bd = new BodyDef();
    bd.position = box2d.coordPixelsToWorld(x, y);
    bd.type = BodyType.DYNAMIC;
    body = box2d.createBody(bd);
    CircleShape cs = new CircleShape();
    cs.m_radius = box2d.scalarPixelsToWorld(r);
    body.createFixture(fd,1);

    // &quot;this&quot; refers to this Particle object.
    // We are telling the Box2D Body to store a
    // reference to this Particle that we can
    // access later.
    body.setUserData(this);  //[bold]
  }</pre>

<p>Later, in our <strong function="">addContact()</strong> function, once we know the body, we can access the <strong klass="">Particle</strong> object with <strong function="">getUserData()</strong>.</p>

<figure class="screenshot"><img alt="ch05 ex11" src="../images/chapter05/ch05_ex11.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<p><strong example="">Example 5.9: CollisionListening</strong></p>

<pre data-code-language="java" data-type="programlisting">
void beginContact(Contact cp) {

  Fixture f1 = cp.getFixtureA();
  Fixture f2 = cp.getFixtureB();

  Body b1 = f1.getBody();
  Body b2 = f2.getBody();

  //[full] When we pull the &ldquo;user data&rdquo; object out of the Body object, we have to remind our program that it is a Particle object.  Box2D doesn&rsquo;t know this.
  Particle p1 = (Particle) b1.getUserData();
  Particle p2 = (Particle) b2.getUserData();


  //[end]
  //[full] Once we have the particles, we can do anything to them.  Here we
  // just call a function that changes their color.
  p1.change();
  p2.change();

  //[end]
}</pre>

<p>Now, in many cases, we cannot assume that the objects that collided are all <strong klass="">Particle</strong> objects. We might have a sketch with <strong klass="">Boundary</strong> objects, <strong klass="">Particle</strong> objects, <strong klass="">Box</strong> objects, etc. So often we will have to query the &ldquo;user data&rdquo; and find out what kind of object it is before proceeding.</p>

<pre data-code-language="java" data-type="programlisting">
  // Getting a generic object
  Object o1 = b1.getUserData();
  // Asking that object if it&rsquo;s a Particle
  if (o1.getClass() == Particle.class) {
    Particle p = (Particle) o1;
    p.change();
  }</pre>

<p>It should also be noted that due to how Box2D triggers these callbacks, you cannot create or destroy Box2D entities inside of <strong function="">beginContact()</strong>, <strong function="">endContact()</strong>, <strong function="">preSolve()</strong>, or <strong function="">postSolve()</strong>. If you want to do this, you&rsquo;ll need to set a variable inside an object (something like: <strong function="">markForDeletion = true</strong>), which you check during <strong function="">draw()</strong> and then delete objects.</p>

<div data-type="exercise" id="chapter05_exercise11">
<h5>Exercise 5.11</h5>

<p>Consider how polymorphism could help in the above case. Build an example in which several classes extend one class and therefore eliminate the need for such testing.</p>
</div>

<div data-type="exercise" id="chapter05_exercise12">
<h5>Exercise 5.12</h5>

<p>Create a simulation in which <strong klass="">Particle</strong> objects disappear when they collide with one another. Use the methodology I just described.</p>
</div>
</section>
</section>

<section data-type="sect1" id="chapter05_section14">
<h1>5.14 A Brief Interlude&mdash;Integration Methods</h1>

<p><a data-primary="integration" data-type="indexterm">&nbsp;</a></p>

<p>Has the following ever happened to you? You&rsquo;re at a fancy cocktail party regaling your friends with tall tales of software physics simulations. Someone pipes up: &ldquo;Enchanting! But what integration method are you using?&rdquo; &ldquo;What?!&rdquo; you think to yourself. &ldquo;Integration?&rdquo;</p>

<p>Maybe you&rsquo;ve heard the term before. Along with &ldquo;differentiation,&rdquo; it&rsquo;s one of the two main operations in calculus. Right, calculus. The good news is, we&rsquo;ve gotten through about 90% of the material in this book related to physics simulation and we haven&rsquo;t really needed to dive into calculus. But as we&rsquo;re coming close to finishing this topic, it&rsquo;s worth taking a moment to examine the calculus behind what we have been doing and how it relates to the methodology in certain physics libraries (like Box2D and the upcoming toxiclibs).</p>

<p><a data-primary="derivatives" data-type="indexterm">&nbsp;</a> <a data-primary="differentiation" data-type="indexterm">&nbsp;</a></p>

<p>Let&rsquo;s begin by answering the question: &ldquo;What does integration have to do with location, velocity, and acceleration?&rdquo; Well, first let&rsquo;s define <strong><em>differentiation</em></strong>, the process of finding a &ldquo;derivative.&rdquo; The derivative of a function is a measure of how a function changes over time. Consider location and its derivative. Location is a point in space, while velocity is change in location over time. Therefore, velocity can be described as the &ldquo;derivative&rdquo; of location. What is acceleration? The change in velocity over time&mdash;i.e. the &ldquo;derivative&rdquo; of velocity.</p>

<p>Now that we understand the derivative (differentiation), we can define the integral (integration) as the inverse of the derivative. In other words, the integral of an object&rsquo;s velocity over time tells us the object&rsquo;s new location when that time period ends. Location is the integral of velocity, and velocity is the integral of acceleration. Since our physics simulation is founded upon the process of calculating acceleration based on forces, we need integration to figure out where the object is after a certain period of time (like one frame of animation!)</p>

<p>So we&rsquo;ve been doing integration all along! It looks like this:</p>

<pre data-code-language="java" data-type="programlisting">
velocity.add(acceleration);
location.add(velocity);</pre>

<p><a data-primary="Euler integration" data-type="indexterm">&nbsp;</a> <a data-primary="Euler" data-secondary="Leonhard" data-type="indexterm">&nbsp;</a> <a data-primary="integration" data-secondary="Euler integration" data-type="indexterm">&nbsp;</a></p>

<p>The above methodology is known as Euler integration (named for the mathematician Leonhard Euler, pronounced &ldquo;Oiler&rdquo;) or the Euler method. It&rsquo;s essentially the simplest form of integration and very easy to implement in our code (see the two lines above!) However, it is not necessarily the most efficient form, nor is it close to being the most accurate. Why is Euler inaccurate? Let&rsquo;s think about it this way. When you drive a car down the road pressing the gas pedal with your foot and accelerating, does the car sit in one location at time equals one second, then disappear and suddenly reappear in a new location at time equals two seconds, and do the same thing for three seconds, and four, and five? No, of course not. The car moves continuously down the road. But what&rsquo;s happening in our Processing sketch? A circle is at one location at frame 0, another at frame 1, another at frame 2. Sure, at thirty frames per second, we&rsquo;re seeing the illusion of motion. But we only calculate a new location every <strong class="var">N</strong> units of time, whereas the real world is perfectly continuous. This results in some inaccuracies, as shown in the diagram below:</p>

<figure id="chapter05_figure13"><img alt="Figure 5.13" src="../images/chapter05/ch05_13.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<p>The &ldquo;real world&rdquo; is the curve; Euler simulation is the series of line segments.</p>

<p>One option to improve on Euler is to use smaller timesteps&mdash;instead of once per frame, we could recalculate an object&rsquo;s location twenty times per frame. But this isn&rsquo;t practical; our sketch would then run too slowly.</p>

<p><a data-primary="Euler integration" data-secondary="symplectic Euler (Box2D)" data-type="indexterm">&nbsp;</a> <a data-primary="symplectic Euler (Box2D)" data-type="indexterm">&nbsp;</a></p>

<p>I still believe that Euler is the best method for learning the basics, and it&rsquo;s also perfectly adequate for most of the projects we might make in Processing. Anything we lose in efficiency or inaccuracy we make up in ease of use and understandability. For better accuracy, Box2D uses something called <a href="http://en.wikipedia.org/wiki/Symplectic_Euler_method">symplectic Euler or semi-explicit Euler</a>, a slight modification of Euler.</p>

<p><a data-primary="integration" data-secondary="Runge-Kutta method" data-type="indexterm">&nbsp;</a> <a data-primary="Kutta" data-secondary="M. W." data-type="indexterm">&nbsp;</a> <a data-primary="Runge" data-secondary="C." data-type="indexterm">&nbsp;</a> <a data-primary="Runge-Kutta method" data-type="indexterm">&nbsp;</a></p>

<p>There is also an integration method called Runge-Kutta (named for German mathematicians C. Runge and M. W. Kutta), which is used in some physics engines.</p>

<p><a data-primary="particle systems" data-secondary="Verlet integration and" data-type="indexterm">&nbsp;</a> <a data-primary="Verlet integration" data-type="indexterm">&nbsp;</a></p>

<p>A very popular integration method that our next physics library uses is known as &ldquo;Verlet integration.&rdquo; A simple way to describe Verlet integration is to think of our typical motion algorithm without velocity. After all, we don&rsquo;t really need to store the velocity. If we always know where an object was at one point in time and where it is now, we can extrapolate its velocity. Verlet integration does precisely this, though instead of having a variable for velocity, it calculates velocity while the program is running. Verlet integration is particularly well suited for particle systems, especially particle systems with spring connections between the particles. We don&rsquo;t need to worry about the details because toxiclibs, as we&rsquo;ll see below, takes care of them for us. However, if you are interested, here is the seminal paper on Verlet physics, from which just about every Verlet computer graphics simulation is derived: <a href="http://www.gamasutra.com/resource_guide/20030121/jacobson_pfv.htm">&quot;Advanced Character Physics&quot;</a>. And of course, you can find out more about Verlet integration from <a href="http://en.wikipedia.org/wiki/Verlet_integration">Wikipedia</a>.</p>
</section>

<section data-type="sect1" id="chapter05_section15">
<h1>5.15 Verlet Physics with toxiclibs</h1>

<p><a data-primary="Processing" data-secondary="toxiclibs and" data-type="indexterm">&nbsp;</a> <a data-primary="Schmidt" data-secondary="Karsten" data-type="indexterm">&nbsp;</a> <a data-primary="toxiclibs" data-type="indexterm">&nbsp;</a> <a data-primary="Verlet integration" data-secondary="toxiclibs" data-type="indexterm">&nbsp;</a></p>

<p>From toxiclibs.org:</p>

<p><em>&ldquo;toxiclibs is an independent, open source library collection for computational design tasks with Java &amp; Processing developed by Karsten &ldquo;toxi&rdquo; Schmidt (thus far). The classes are purposefully kept fairly generic in order to maximize re-use in different contexts ranging from generative design, animation, interaction/interface design, data visualization to architecture and digital fabrication, use as teaching tool and more.&rdquo;</em></p>

<p>In other words, we should thank our lucky stars for toxiclibs. We are only going to focus on a few examples related to Verlet physics, but toxiclibs includes a suite of other wonderful packages that help with audio, color, geometry, and more. In particular, if you are looking to work with form and fabrication in Processing, take a look at the geometry package. Demos can be found at <a href="http://www.openprocessing.org/portal/?userID=4530">Open Processing</a>.</p>

<p>We should note that toxiclibs was designed specifically for use with Processing. This is great news. The trouble we had with making Box2D work in Processing (multiple coordinate systems, Box2D vs. JBox2D vs. PBox2D) is not an issue here. toxiclibs is a library that you just download, stick in your libraries folder, and use. And the coordinate system that we&rsquo;ll use for the physics engine is the coordinate system of Processing, so no translating back and forth. In addition, toxiclibs is not limited to a 2D world; all of the physics simulations and functions work in both two and three dimensions. So how do you decide which library you should use? Box2D or toxiclibs? If you fall into one of the following two categories, your decision is a bit easier:</p>

<p><a data-primary="Box2D" data-secondary="toxiclibs vs." data-type="indexterm">&nbsp;</a> <a data-primary="collisions" data-secondary="toxiclibs and" data-type="indexterm">&nbsp;</a> <a data-primary="toxiclibs" data-secondary="Box2D vs." data-type="indexterm">&nbsp;</a></p>

<p><strong>1. My project involves collisions. I have circles, squares, and other strangely shaped objects that knock each other around and bounce off each other.</strong></p>

<p>In this case, you are going to need Box2D. toxiclibs does not handle collisions.</p>

<p><strong>2. My project involves lots of particles flying around the screen. Sometimes they attract each other. Sometimes they repel each other. And sometimes they are connected with springs.</strong></p>

<p>In this case, toxiclibs is likely your best choice. It is simpler to use than Box2D and particularly well suited to connected systems of particles. toxiclibs is also very high performance, due to the speed of the Verlet integration algorithm (not to mention the fact that the program gets to ignore all of the collision geometry).</p>

<p>Here is a little chart that covers some of the features for each physics library.</p>

<table>
	<thead>
		<tr>
			<th>Feature</th>
			<th>Box2D</th>
			<th>toxiclibs VerletPhysics</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>
			<p>Collision geometry</p>
			</td>
			<td>
			<p>Yes</p>
			</td>
			<td>
			<p>No</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>3D physics</p>
			</td>
			<td>
			<p>No</p>
			</td>
			<td>
			<p>Yes</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>Particle attraction / repulsion forces</p>
			</td>
			<td>
			<p>No</p>
			</td>
			<td>
			<p>Yes</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>Spring connections</p>
			</td>
			<td>
			<p>Yes</p>
			</td>
			<td>
			<p>Yes</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>Other connections: revolute, pulley, gear, prismatic</p>
			</td>
			<td>
			<p>Yes</p>
			</td>
			<td>
			<p>No</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>Motors</p>
			</td>
			<td>
			<p>Yes</p>
			</td>
			<td>
			<p>No</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>Friction</p>
			</td>
			<td>
			<p>Yes</p>
			</td>
			<td>
			<p>No</p>
			</td>
		</tr>
	</tbody>
</table>

<section data-type="sect2" id="_getting_toxiclibs">
<h2>Getting toxiclibs</h2>

<p><a data-primary="toxiclibs" data-secondary="downloading" data-type="indexterm">&nbsp;</a></p>

<p>Everything you need to download and install toxiclibs can be found at:</p>

<p><a href="http://toxiclibs.org/">toxiclibs</a></p>

<p>When you download the library, you&rsquo;ll notice that it comes with eight modules (i.e. sub-folders), each a library in its own right. For the examples in this chapter, you will only need &ldquo;verletphysics&rdquo; and &ldquo;toxiclibscore&rdquo;; however, I recommend you take a look at and consider using all of the modules!</p>

<p>Once you have the library installed to your <a href="http://wiki.processing.org/w/How_to_Install_a_Contributed_Library">Processing library folder</a>, you are ready to start looking at the following examples.</p>
</section>

<section data-type="sect2" id="_core_elements_of_verletphysics">
<h2>Core Elements of VerletPhysics</h2>

<p><a data-primary="VerletPhysics class (toxiclibs)" data-secondary="core elements of" data-type="indexterm">&nbsp;</a></p>

<p>We spent a lot of time working through the core elements of a Box2D world: world, body, shape, joint. This gives us a head start on understanding toxiclibs, since it follows a similar structure.</p>

<table>
	<thead>
		<tr>
			<th>Box2D</th>
			<th>toxiclibs VerletPhysics</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>
			<p>World</p>
			</td>
			<td>
			<p>VerletPhysics</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>Body</p>
			</td>
			<td>
			<p>VerletParticle</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>Shape</p>
			</td>
			<td>
			<p>Nothing! toxiclibs does not handle shape geometry</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>Fixture</p>
			</td>
			<td>
			<p>Nothing! toxiclibs does not handle shape geometry</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>Joint</p>
			</td>
			<td>
			<p>VerletSpring</p>
			</td>
		</tr>
	</tbody>
</table>
</section>

<section data-type="sect2" id="_vectors_with_toxiclibs">
<h2>Vectors with toxiclibs</h2>

<p><a data-primary="Vec2D (toxiclibs type)" data-type="indexterm">&nbsp;</a> <a data-primary="Vec3D (toxiclibs type)" data-type="indexterm">&nbsp;</a></p>

<p>Here we go again. Remember all that time we spent learning the ins and outs of the <strong klass="">PVector</strong> class? Then remember how when we got to Box2D, we had to translate all those concepts to a Box2D vector class: <strong klass="">Vec2</strong>? Well, it&rsquo;s time to do it again. toxiclibs also includes its own vector classes, one for two dimensions and one for three: <strong klass="">Vec2D</strong> and <strong klass="">Vec3D</strong>.</p>

<p>Again, toxiclibs vectors are the same conceptually, but we need to learn a bit of new syntax. You can find all of the documentation for these vector classes here:</p>

<p><a href="http://toxiclibs.org/docs/core/toxi/geom/Vec2D.html">Vec2D</a><br />
<a href="http://toxiclibs.org/docs/core/toxi/geom/Vec3D.html">Vec3D</a></p>

<p>And let&rsquo;s just review some of the basic vector math operations with <strong klass="">PVector</strong> translated to <strong klass="">Vec2D</strong> (we&rsquo;re sticking with 2D for simplicity&rsquo;s sake).</p>

<p><a data-primary="Vec2D (toxiclibs type)" data-secondary="math functions for" data-type="indexterm">&nbsp;</a></p>

<table class="code">
	<tbody>
		<tr>
			<th>PVector</th>
			<th>Vec2D</th>
		</tr>
		<tr>
			<td>
			<pre>
PVector a = new PVector(1,-1);
PVector b = new PVector(3,4);
a.add(b);
</pre>
			</td>
			<td>
			<pre>
Vec2D a = new Vec2D(1,-1);
Vec2D b = new Vec2D(3,4);
a.addSelf(b);
</pre>
			</td>
		</tr>
		<tr>
			<td>
			<pre>
PVector a = new PVector(1,-1);
PVector b = new PVector(3,4);
PVector c = PVector.add(a,b);
</pre>
			</td>
			<td>
			<pre>
Vec2D a = new Vec2D(1,-1);
Vec2D b = new Vec2D(3,4);
Vec2D c = a.add(b);
</pre>
			</td>
		</tr>
		<tr>
			<td>
			<pre>
PVector a = new PVector(1,-1);
float m = a.mag();
a.normalize();
</pre>
			</td>
			<td>
			<pre>
Vec2D a = new Vec2D(1,-1);
float m = a.magnitude();
a.normalize();
</pre>
			</td>
		</tr>
	</tbody>
</table>
</section>

<section data-type="sect2" id="_building_the_toxiclibs_physics_world">
<h2>Building the toxiclibs physics world</h2>

<p><a data-primary="toxiclibs" data-secondary="world" data-tertiary="building" data-type="indexterm">&nbsp;</a></p>

<p>The first thing we need to do to create a toxiclibs physics world in our examples is import the library itself.</p>

<pre data-code-language="java" data-type="programlisting">
//[full] Importing the libraries
import toxi.physics2d.*;
import toxi.physics2d.behaviors.*;
import toxi.geom.*;
//[end]</pre>

<p><a data-primary="toxiclibs" data-secondary="VerletPhysics class" data-type="indexterm">&nbsp;</a> <a data-primary="toxiclibs" data-secondary="VerletPhysics2D class" data-type="indexterm">&nbsp;</a> <a data-primary="VerletPhysics class (toxiclibs)" data-type="indexterm">&nbsp;</a> <a data-primary="VerletPhysics2D class (toxiclibs)" data-type="indexterm">&nbsp;</a></p>

<p>Then we&rsquo;ll need a reference to our physics world, a <strong klass="">VerletPhysics</strong> or <strong klass="">VerletPhysics2D</strong> object (depending on whether we are working in two or three dimensions). The examples in this chapter will operate in 2D only for simplicity, but they could easily be extended into 3D (and 3D versions are available with the chapter download).</p>

<pre data-code-language="java" data-type="programlisting">
VerletPhysics2D physics;

void setup() {
  // Creating a toxiclibs Verlet physics world
  physics=new VerletPhysics2D();</pre>

<p>Once you have your <strong klass="">VerletPhysics</strong> object, you can set some global properties for your world. For example, if you want it to have hard boundaries past which objects cannot travel, you can set its limits:</p>

<pre data-code-language="java" data-type="programlisting">
  physics.setWorldBounds(new Rect(0,0,width,height));</pre>

<p><a data-primary="gravity" data-secondary="GravityBehavior (toxiclibs)" data-type="indexterm">&nbsp;</a> <a data-primary="GravityBehavior class (toxiclibs)" data-type="indexterm">&nbsp;</a></p>

<p>In addition, you can add gravity to the physics world with a <strong klass="">GravityBehavior</strong> object. A gravity behavior requires a vector&mdash;how strong and in what direction is the gravity?</p>

<pre data-code-language="java" data-type="programlisting">
  physics.addBehavior(new GravityBehavior(new Vec2D(0,0.5)));
}</pre>

<p><a data-primary="update() function (toxiclibs)" data-type="indexterm">&nbsp;</a></p>

<p>Finally, in order to calculate the physics of the world and move the objects in the world, we have to call <strong function="">update()</strong>. Typically this would happen once per frame in <strong function="">draw()</strong>.</p>

<pre data-code-language="java" data-type="programlisting">
void draw() {
  // This is the same as Box2D&rsquo;s &ldquo;step()&rdquo; function
  physics.update();
}</pre>
</section>
</section>

<section data-type="sect1" id="chapter05_section16">
<h1>5.16 Particles and Springs in toxiclibs</h1>

<p><a data-primary="particles" data-secondary="toxiclibs implementation of" data-type="indexterm">&nbsp;</a> <a data-primary="toxiclibs" data-secondary="particles" data-tertiary="implementing in" data-type="indexterm">&nbsp;</a></p>

<p>In the Box2D examples, we saw how we can create our own class (called, say, <strong klass="">Particle</strong>) and include a reference to a Box2D body.</p>

<pre data-code-language="java" data-type="programlisting">
class Particle {
  Body body;</pre>

<p>This technique is somewhat redundant since Box2D itself keeps track of all of the bodies in its world. However, it allows us to manage which body is which (and therefore how each body is drawn) without having to rely on iterating through Box2D&rsquo;s internal lists.</p>

<p><a data-primary="particles" data-secondary="VerletParticle2D object (toxiclibs)" data-type="indexterm">&nbsp;</a> <a data-primary="VerletParticle2D object (toxiclibs)" data-type="indexterm">&nbsp;</a></p>

<p>Let&rsquo;s look at how we might take the same approach with the class <strong klass="">VerletParticle2D</strong> in toxiclibs. We want to make our own <strong klass="">Particle</strong> class so that we can draw our particles a certain way and include any custom properties. We&rsquo;d probably write our code as follows:</p>

<pre data-code-language="java" data-type="programlisting">
class Particle {
  // Our Particle has a reference to a VerletParticle.
  VerletParticle2D p;

  Particle(Vec2D pos) {
    // A VerletParticle needs an initial location (an x and y).
    p = new VerletParticle2D(pos);
  }

  void display() {
    fill(0,150);
    stroke(0);
    // When it comes time to draw the Particle, we ask the
    // VerletParticle for its x and y coordinates.
    ellipse(p.x,p.y,16,16);
  }
}</pre>

<p>Looking at the above, we should first be thrilled to notice that drawing the particle is as simple as grabbing the <em>x</em> and <em>y</em> and using them. No awkward conversions between coordinate systems here since toxiclibs is designed to think in pixels. Second, you might notice that this <strong klass="">Particle</strong> class&rsquo;s sole purpose is to store a reference to a <strong klass="">VerletParticle2D</strong> object. This hints at something. Remember our discussion of inheritance back in Chapter 4: Particle Systems? What is a <strong klass="">Particle</strong> object other than an &ldquo;augmented&rdquo; <strong klass="">VerletParticle</strong>? Why bother making a Verlet particle inside a particle when we could simply <strong klass="">extend VerletParticle</strong>?</p>

<pre data-code-language="java" data-type="programlisting">
class Particle extends VerletParticle2D {

  Particle(Vec2D loc) {
    // Calling super() so that the object is initialized properly
    super(loc);
  }

  // We want this to be just like a VerletParticle, only with a display() method.
  void display() {
    fill(175);
    stroke(0);
    // We&rsquo;ve inherited x and y from VerletParticle!
    ellipse(x,y,16,16);
  }
}</pre>

<p>Remember our multi-step process with the Box2D examples? We had to ask the body for its location, then convert that location to pixels, then use that location in a drawing function. Now, because we have inherited everything from the <strong klass="">VerletParticle</strong> class, our only step is to draw the shape at <strong class="var">x</strong> and <strong class="var">y</strong>!</p>

<p><a data-primary="Vec2D (toxiclibs type)" data-secondary="VerletParticle2D class and" data-type="indexterm">&nbsp;</a></p>

<p>Incidentally, it&rsquo;s interesting to note that the <strong klass="">VerletParticle2D</strong> class is a subclass of <strong klass="">Vec2D</strong>. So in addition to inheriting everything from <strong klass="">VerletParticle2D</strong>, our <strong klass="">Particle</strong> class actually has all of the <strong klass="">Vec2D</strong> functions available as well.</p>

<p>We can now create particles anywhere within our sketch.</p>

<pre data-code-language="java" data-type="programlisting">
  Particle p1 = new Particle(new Vec2D(100,20));
  Particle p2 = new Particle(new Vec2D(100,180));</pre>

<p><a data-primary="addParticle() function (toxiclibs)" data-type="indexterm">&nbsp;</a> <a data-primary="particle systems" data-secondary="addParticle() function (toxiclibs)" data-type="indexterm">&nbsp;</a></p>

<p>Just making a particle isn&rsquo;t enough, however. We have to make sure we tell our physics world about them with the <strong function="">addParticle()</strong> function.</p>

<pre data-code-language="java" data-type="programlisting">
  physics.addParticle(p1);
  physics.addParticle(p2);</pre>

<p>If you look at the toxiclibs documentation, you&rsquo;ll see that the <strong function="">addParticle()</strong> expects a <strong klass="">VerletParticle2D</strong> object.</p>

<p><strong function="">addParticle(VerletParticle2D particle)</strong></p>

<p>And how can we then pass into the function our own <strong klass="">Particle</strong> object? Remember that other tenet of object-oriented programming&mdash;polymorphism? Here, because our <strong klass="">Particle</strong> class <strong klass="">extends VerletParticle2D</strong>, we can choose to treat our particle in two different ways&mdash;as a <strong klass="">Particle</strong> or as a <strong klass="">VerletParticle2D</strong>. This is an incredibly powerful feature of object-oriented programming. If we build our custom classes based on classes from toxiclibs, we can use our objects in conjunction with all of the functions toxiclibs has to offer.</p>

<p><a data-primary="springs" data-secondary="toxiclibs and" data-type="indexterm">&nbsp;</a> <a data-primary="toxiclibs" data-secondary="springs" data-type="indexterm">&nbsp;</a></p>

<p>In addition to the <strong klass="">VerletParticle</strong> class, toxiclibs has a set of classes that allow you to connect particles with spring forces. There are three types of springs in toxiclibs:</p>

<p><a data-primary="springs" data-secondary="VerletConstrainedSpring class (toxiclibs)" data-type="indexterm">&nbsp;</a> <a data-primary="springs" data-secondary="VerletMinDistanceSpring class (toxiclibs)" data-type="indexterm">&nbsp;</a> <a data-primary="springs" data-secondary="VerletSpring class (toxiclibs)" data-type="indexterm">&nbsp;</a> <a data-primary="VerletConstrainedSpring class (toxiclibs)" data-type="indexterm">&nbsp;</a> <a data-primary="VerletMinDistanceSpring class (toxiclibs)" data-type="indexterm">&nbsp;</a> <a data-primary="VerletSpring class (toxiclibs)" data-type="indexterm">&nbsp;</a></p>

<ul>
	<li>
	<p><strong klass="">VerletSpring</strong>: This class creates a springy connection between two particles in space. A spring&rsquo;s properties can be configured in such a way as to create a stiff stick-like connection or a highly elastic stretchy connection. A particle can also be locked so that only one end of the spring can move.</p>
	</li>
	<li>
	<p><strong klass="">VerletConstrainedSpring</strong>: A <strong klass="">VerletConstrainedSpring</strong> object is a spring whose maximum distance can be limited. This can help the whole spring system achieve better stability.</p>
	</li>
	<li>
	<p><strong klass="">VerletMinDistanceSpring</strong>: A <strong klass="">VerletMinDistanceSpring</strong> object is a spring that only enforces its rest length if the current distance is less than its rest length. This is handy if you want to ensure objects are at least a certain distance from each other, but don&rsquo;t care if the distance is bigger than the enforced minimum.</p>
	</li>
</ul>

<p>The inheritance and polymorphism technique we employed in the previous section also proves to be useful when creating springs. A spring expects two particles when it is created. And again, because our <strong klass="">Particle</strong> class <strong klass="">extends VerletParticle</strong>, a <strong klass="">VerletSpring</strong> object will accept our <strong klass="">Particle</strong> objects passed into the constructor. Let&rsquo;s take a look at some example code that assumes the existence of our two previous particles <strong class="var">p1</strong> and <strong class="var">p2</strong> and creates a connection between them with a given rest length and strength.</p>

<pre data-code-language="java" data-type="programlisting">
// What is the rest length of the spring?
float len = 80;
// How strong is the spring?
float strength = 0.01;
VerletSpring2D spring=new VerletSpring2D(p1,p2,len,strength);</pre>

<p>Just as with particles, in order for the connection to actually be part of the physics world, we need to explicitly add it.</p>

<pre data-code-language="java" data-type="programlisting">
physics.addSpring(spring);</pre>
</section>

<section data-type="sect1" id="chapter05_section17">
<h1>5.17 Putting It All Together: A Simple Interactive Spring</h1>

<p><a data-primary="lock() function (toxiclibs)" data-type="indexterm">&nbsp;</a> <a data-primary="springs" data-secondary="lock() function (toxiclibs)" data-type="indexterm">&nbsp;</a></p>

<p>One thing we saw with Box2D is that the physics simulation broke down when we overrode it and manually set the location of a body. With toxiclibs, we don&rsquo;t have this problem. If we want to move the location of a particle, we can simply set its <em>x</em> and <em>y</em> location manually. However, before we do so, it&rsquo;s generally a good idea to call the <strong function="">lock()</strong> function.</p>

<p><strong function="">lock()</strong> is typically used to lock a particle in place and is identical to setting a Box2D body&rsquo;s density to 0. However, here we are going to show how to lock a particle temporarily, move it, and then unlock it so that it continues to move according to the physics simulation. Let&rsquo;s say you want to move a given particle whenever you click the mouse.</p>

<pre data-code-language="java" data-type="programlisting">
  if (mousePressed) {
    //[full] First lock the particle, then set the x and y, then unlock() it.
    p2.lock();
    p2.x = mouseX;
    p2.y = mouseY;
    p2.unlock();
    //[end]
  }</pre>

<p>And now we&rsquo;re ready to put all of these elements together in a simple example that connects two particles with a spring. One particle is locked in place, and the other can be moved by dragging the mouse. Note that this example is virtually identical to <a href="#chapter03_example11">Example 3.11</a>.</p>

<figure class="screenshot"><img alt="ch05 ex12" src="../images/chapter05/ch05_ex12.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<p><strong example="">Example 5.10: Simple Spring with toxiclibs</strong></p>

<pre data-code-language="java" data-type="programlisting">
import toxi.physics2d.*;
import toxi.physics2d.behaviors.*;
import toxi.geom.*;

VerletPhysics2D physics;
Particle p1;
Particle p2;

void setup() {
  size(640,360);

  // Creating a physics world
  physics=new VerletPhysics2D();
  physics.addBehavior(new GravityBehavior2D(new Vec2D(0,0.5)));
  physics.setWorldBounds(new Rect(0,0,width,height));

  // Creating two Particles
  p1 = new Particle(new Vec2D(100,20));
  p2 = new Particle(new Vec2D(100,180));
  // Locking Particle 1 in place
  p1.lock();

  //[offset-down] Creating one Spring
  VerletSpring2D spring=new VerletSpring2D(p1,p2,80,0.01);

  // Must add everything to the world
  physics.addParticle(p1);
  physics.addParticle(p2);
  physics.addSpring(spring);
}

void draw() {
  // Must update the physics
  physics.update();

  background(255);

  // Drawing everything
  line(p1.x,p1.y,p2.x,p2.y);
  p1.display();
  p2.display();

  if (mousePressed) {
    //[full] Moving a Particle according to the mouse
    p2.lock();
    p2.x = mouseX;
    p2.y = mouseY;
    p2.unlock();
    //[end]
  }
}

//[full] How cute is our simple Particle class?!
class Particle extends VerletParticle2D {

  Particle(Vec2D loc) {
    super(loc);
  }

  void display() {
    fill(175);
    stroke(0);
    ellipse(x,y,16,16);
  }
}
//[end]</pre>
</section>

<section data-type="sect1" id="chapter05_section18">
<h1>5.18 Connected Systems, Part I: String</h1>

<p><a data-primary="connected systems" data-secondary="strings" data-type="indexterm">&nbsp;</a> <a data-primary="toxiclibs" data-secondary="connected systems" data-type="indexterm">&nbsp;</a></p>

<p>The above example, two particles connected with a single spring, is the core building block for what toxiclibs&rsquo; physics is particularly well suited for: soft body simulations. For example, a string can be simulated by connecting a line of particles with springs. A blanket can be simulated by connecting a grid of particles with springs. And a cute, cuddly, squishy cartoon character can be simulated by a custom layout of particles connected with springs.</p>

<figure id="chapter05_figure14"><img alt="Figure 5.14" src="../images/chapter05/ch05_14.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<p>Let&rsquo;s begin by simulating a &ldquo;soft pendulum&rdquo;&mdash;a bob hanging from a string, instead of a rigid arm like we had in <a href="#chapter03_example10">Chapter 3, Example 10</a>. Let&rsquo;s use the &quot;string&quot; in Figure 5.14 above as our model.</p>

<p>First, we&rsquo;ll need a list of particles (let&rsquo;s use the same <strong klass="">Particle</strong> class we built in the previous example).</p>

<pre data-code-language="java" data-type="programlisting">
ArrayList&lt;Particle&gt; particles = new ArrayList&lt;Particle&gt;();</pre>

<p>Now, let&rsquo;s say we want to have 20 particles, all spaced 10 pixels apart.</p>

<figure id="chapter05_figure15"><img alt="Figure 5.15" src="../images/chapter05/ch05_15.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<pre data-code-language="java" data-type="programlisting">
float len = 10;
float numParticles = 20;</pre>

<p>We can loop from <strong class="var">i</strong> equals 0 all the way up to 20, with each particle&rsquo;s <em>y</em> location set to <strong class="var">i <code>*</code> 10</strong> so that the first particle is at <em>(0,10)</em>, the second at <em>(0,20)</em>, the third at <em>(0,30)</em>, etc.</p>

<pre data-code-language="java" data-type="programlisting">
for(int i=0; i &lt; numPoints; i++) {
  // Spacing them out along the x-axis
  Particle particle=new Particle(i*len,10);
  // Add the particle to our list.
  physics.addParticle(particle);
  // Add the particle to the physics world.
  particles.add(particle);
}</pre>

<p>Even though it&rsquo;s a bit redundant, we&rsquo;re going to add the particle to both the toxiclibs physics world and to our own list. In case we eventually have multiple strings, this will allow us to know which particles are connected to which strings.</p>

<p>Now for the fun part: It&rsquo;s time to connect all the particles. Particle 1 will be connected to particle 0, particle 2 to particle 1, 3 to 2, 4 to 3, etc.</p>

<figure id="chapter05_figure16"><img alt="Figure 5.16" src="../images/chapter05/ch05_16.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<p>In other words, particle <strong class="var">i</strong> needs to be connected to particle <strong class="var">i-1</strong> (except for when <strong class="var">i</strong> equals zero).</p>

<pre data-code-language="java" data-type="programlisting">
if (i != 0) {
  // First we need a reference to the previous particle.
  Particle previous = particles.get(i-1);

  //[offset-down] Then we make a spring connection between the particle and the previous particle with a rest length and strength (both floats).
  VerletSpring2D spring = new VerletSpring2D(particle,previous,len,strength);




  // We must not forget to add the spring to the physics world.
  physics.addSpring(spring);
}</pre>

<p><a data-primary="strings" data-secondary="hanging from fixed points" data-type="indexterm">&nbsp;</a></p>

<p>Now, what if we want the string to hang from a fixed point? We can lock one of the particles&mdash;the first, the last, the middle one, etc. Here&rsquo;s how we would access the first particle (in the <strong klass="">ArrayList</strong>) and lock it.</p>

<pre data-code-language="java" data-type="programlisting">
Particle head=particles.get(0);
head.lock();</pre>

<p>And if we want to draw all the particles as being connected with a line, along with a circle for the last particle, we can use <strong function="">beginShape()</strong>, <strong function="">endShape()</strong>, and <strong function="">vertex()</strong>, accessing the particle locations from our <strong klass="">ArrayList</strong>.</p>

<figure class="screenshot"><img alt="ch05 ex13" src="../images/chapter05/ch05_ex13.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<p><strong example="">Example 5.11: Soft swinging pendulum</strong></p>

<pre data-code-language="java" data-type="programlisting">
stroke(0);
noFill();
beginShape();
for (Particle p : particles) {
  // Each particle is one point in the line.
  vertex(p.x,p.y);
}
endShape();
Particle tail = particles.get(numPoints-1);
// This draws the last particle as a circle.
tail.display();</pre>

<p>The full code available with the chapter download also demonstrates how to drag the tail particle with the mouse.</p>

<div data-type="exercise" id="chapter05_exercise13">
<h5>Exercise 5.13</h5>

<p>Create a hanging cloth simulation using the technique above, but connect all the particles with a grid as demonstrated in the screenshot below.</p>

<figure class="screenshot"><img alt="ch05 exc13" src="../images/chapter05/ch05_exc13.png" />
<figcaption>&nbsp;</figcaption>
</figure>
</div>
</section>

<section data-type="sect1" id="chapter05_section19">
<h1>5.19 Connected Systems, Part II: Force-Directed Graph</h1>

<p><a data-primary="connected systems" data-secondary="force-directed graphs" data-type="indexterm">&nbsp;</a> <a data-primary="force-directed graphs" data-type="indexterm">&nbsp;</a> <a data-primary="toxiclibs" data-secondary="force-directed graphs" data-type="indexterm">&nbsp;</a></p>

<p>Have you ever encountered the following scenario?</p>

<p>&ldquo;I have a whole bunch of stuff I want to draw on the screen and I want all that stuff to be spaced out evenly in a nice, neat, organized manner. Otherwise I have trouble sleeping at night.&rdquo;</p>

<p>This is not an uncommon problem in computational design. One solution is typically referred to as a &ldquo;force-directed graph.&rdquo; A force-directed graph is a visualization of elements&mdash;let&rsquo;s call them &ldquo;nodes&rdquo;&mdash;in which the positions of those nodes are not manually assigned. Rather, the nodes arrange themselves according to a set of forces. While any forces can be used, a typical example involves spring forces. And so toxiclibs is perfect for this scenario.</p>

<figure class="three-col"><img alt="ch05 ex14" src="../images/chapter05/ch05_ex14.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<figure class="three-col"><img alt="ch05 ex15" src="../images/chapter05/ch05_ex15.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<figure class="three-col"><img alt="ch05 ex16" src="../images/chapter05/ch05_ex16.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<p>How do we implement the above?</p>

<p>First, we&rsquo;ll need a <strong klass="">Node</strong> class. This is the easy part; it can <strong klass="">extend VerletParticle2D</strong>. Really, this is just what we did before, only we&rsquo;re calling it <strong klass="">Node</strong> now instead of <strong klass="">Particle</strong>.</p>

<pre data-code-language="java" data-type="programlisting">
class Node extends VerletParticle2D {
  Node(Vec2D pos) {
    super(pos);
  }

  void display() {
    fill(0,150);
    stroke(0);
    ellipse(x,y,16,16);
  }
}</pre>

<p>Next we can write a class called <strong klass="">Cluster</strong>, which will describe a list of nodes.</p>

<pre data-code-language="java" data-type="programlisting">
class Cluster {

  ArrayList&lt;Node&gt; nodes;

  // We&rsquo;ll use this variable for the rest
  // length between all the nodes.
  float diameter;

  Cluster(int n, float d, Vec2D center) {
    nodes = new ArrayList&lt;Node&gt;();
    diameter = d;

    for (int i = 0; i &lt; n; i++) {
      //[offset-down] Here&rsquo;s a funny little detail.  We&rsquo;re going to have a problem
      // if all the Node objects start in exactly the same location.
      // So we add a random vector to the center location so that each
      // Node is slightly offset.
      nodes.add(new Node(center.add(Vec2D.randomVector())));



    }
  }</pre>

<p>Let&rsquo;s assume we added a <strong function="">display()</strong> function to draw all the nodes in the cluster and created a <strong klass="">Cluster</strong> object in <strong function="">setup()</strong> and displayed it in <strong function="">draw()</strong>. If we ran the sketch as is, nothing would happen. Why? Because we forgot the whole force-directed graph part! We need to connect every single node to every other node with a force. But what exactly do we mean by that? Let&rsquo;s assume we have four <strong klass="">Node</strong> objects: 0, 1, 2 and 3. Here are our connections:</p>

<p><strong mono="">0 connected to 1<br />
0 connected to 2<br />
0 connected to 3<br />
1 connected to 2<br />
1 connected to 3<br />
2 connected to 3</strong></p>

<p>Notice two important details about our connection list.</p>

<ul>
	<li>
	<p><strong><em>No node is connected to itself.</em></strong> We don&rsquo;t have 0 connected to 0 or 1 connected to 1.</p>
	</li>
	<li>
	<p><strong><em>We don&rsquo;t need to repeat connections in reverse.</em></strong> In other words, if we&rsquo;ve already said 0 is connected to 1, we don&rsquo;t need to say 1 is connected to 0 because, well, it already is!</p>
	</li>
</ul>

<p>So how do we write code to make these connections for <em>N</em> number of nodes?</p>

<p>Look at the left column. It reads: 000 11 22. So we know we need to access each node in the list from 0 to <em>N</em>-1.</p>

<pre data-code-language="java" data-type="programlisting">
    for (int i = 0; i &lt; nodes.size()-1; i++) {
      VerletParticle2D ni = nodes.get(i);</pre>

<p>Now, we know we need to connect node 0 to nodes 1,2,3. For node 1: 2,3. For node 2: 3. So for every node i, we must loop from i+1 until the end of the list.</p>

<pre data-code-language="java" data-type="programlisting">
      // Look how we start j at i + 1.
      for (int j = i+1; j &lt; nodes.size(); j++) { //[bold]
        VerletParticle2D nj = nodes.get(j);</pre>

<p>With every two <strong klass="">Node</strong><code>s</code> we find, all we have to do then is make a spring.</p>

<pre data-code-language="java" data-type="programlisting">
        // The Spring connects Nodes &ldquo;ni&rdquo; and &ldquo;nj&rdquo;.
        physics.addSpring(new VerletSpring2D(ni,nj,diameter,0.01));
      }
    }</pre>

<p>Assuming those connections are made in the <strong klass="">Cluster</strong> constructor, we can now create a cluster in our main tab and see the results!</p>

<figure class="screenshot"><img alt="ch05 ex17" src="../images/chapter05/ch05_ex17.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<p><strong example="">Example 5.12: Cluster</strong></p>

<pre data-code-language="java" data-type="programlisting">
import toxi.geom.*;
import toxi.physics2d.*;

VerletPhysics2D physics;
Cluster cluster;

void setup() {
  size(300,300);
  physics=new VerletPhysics2D();
  //[offset-down] Make a cluster.
  cluster = new Cluster(8,100,new Vec2D(width/2,height/2));
}

void draw() {
  physics.update();
  background(255);
  // Draw the cluster.
  cluster.display();
}</pre>

<div data-type="exercise" id="chapter05_exercise14">
<h5>Exercise 5.14</h5>

<p>Use the <strong klass="">Cluster</strong> structure as a skeleton for a cute, cuddly, squishy creature (&agrave; la &ldquo;Nokia Friends&rdquo;). Add gravity and also allow the creature to be dragged with the mouse.</p>
</div>

<div data-type="exercise" id="chapter05_exercise15">
<h5>Exercise 5.15</h5>

<p>Expand the force-directed graph to have more than one <strong klass="">Cluster</strong> object. Use a <strong klass="">VerletMinDistanceSpring2D</strong> object to connect cluster to cluster.</p>

<figure class="screenshot"><img alt="ch05 exc15" src="../images/chapter05/ch05_exc15.png" />
<figcaption>&nbsp;</figcaption>
</figure>
</div>
</section>

<section data-type="sect1" id="chapter05_section20">
<h1>5.20 Attraction and Repulsion Behaviors</h1>

<p><a data-primary="addForce() function (toxiclibs)" data-type="indexterm">&nbsp;</a> <a data-primary="toxiclibs" data-secondary="attraction/repulsion behaviors and" data-type="indexterm">&nbsp;</a></p>

<p>When we looked at adding an attraction force to Box2D, we found that the Box2D <strong klass="">Body</strong> class included an <strong function="">applyForce()</strong> function. All we needed to do was calculate the attraction force (Force = G * mass1 * mass2 / distance squared) as a vector and apply it to the body. toxiclibs <strong klass="">VerletParticle</strong> class also includes a function called <strong function="">addForce()</strong> that we can use to apply any calculated force to a particle.</p>

<p><a data-primary="AttractionBehavior class (toxiclibs)" data-type="indexterm">&nbsp;</a> <a data-primary="toxiclibs" data-secondary="AttractionBehavior class" data-type="indexterm">&nbsp;</a></p>

<p>However, toxiclibs also takes this idea one step further by allowing us to attach some common forces (let&rsquo;s call them &ldquo;behaviors&rdquo;) to particles, calculating them and applying them for us! For example, if we attach an <strong klass="">AttractionBehavior</strong> object to a particle, then all other particles in the physics world will be attracted to that particle.</p>

<p>Let&rsquo;s say we have a <strong klass="">Particle</strong> class (that <strong klass="">extends VerletParticle</strong>).</p>

<pre data-code-language="java" data-type="programlisting">
Particle p = new Particle(new Vec2D(200,200));</pre>

<p>Once we&rsquo;ve made a <strong klass="">Particle</strong> object, we can create an <strong klass="">AttractionBehavior</strong> object associated with that particle.</p>

<pre data-code-language="java" data-type="programlisting">
float distance = 20;
float strength = 0.1;
AttractionBehavior behavior = new AttractionBehavior(p, distance, strength);</pre>

<p>Notice how the behavior is created with two parameters&mdash;<strong class="var">distance</strong> and <strong class="var">strength</strong>. The distance specifies the range within which the behavior will be applied. For example, in the above scenario, only other particles within twenty pixels will feel the attraction force. The strength, of course, specifies how strong the force is.</p>

<p>Finally, in order for the force to be activated, the behavior needs to be added to the physics world.</p>

<pre data-code-language="java" data-type="programlisting">
physics.addBehavior(behavior);</pre>

<p>This means everything that lives in the physics simulation will always be attracted to that particle, as long as it is within the distance threshold.</p>

<p>Even though toxiclibs does not handle collisions, you can create a collision-like effect by adding a repulsive behavior to each and every particle (so that every particle repels every other particle). Let&rsquo;s look at how we might modify our <strong klass="">Particle</strong> class to do this.</p>

<pre data-code-language="java" data-type="programlisting">
class Particle extends VerletParticle2D {

  // We&rsquo;ve added a radius to every Particle.
  float r;

  Particle (Vec2D loc) {
    super(loc);
    r = 4;
    //[offset-down] Every time a Particle is made, an AttractionBehavior is
    // generated and added to the physics world.
    // Note that when the strength
    // is negative, it&rsquo;s a repulsive force!
    physics.addBehavior(new AttractionBehavior(this, r*4, -1));
  }

  void display () {
    fill (255);
    stroke (255);
    ellipse (x, y, r*2, r*2);
  }
}</pre>

<p>We could now recreate our attraction example by having a single <strong klass="">Attractor</strong> object that exerts an attraction behavior over the entire window.</p>

<figure class="screenshot"><img alt="ch05 ex18" src="../images/chapter05/ch05_ex18.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<p><strong example="">Example 5.13: Attraction/Repulsion</strong></p>

<pre data-code-language="java" data-type="programlisting">
class Attractor extends VerletParticle2D {

  float r;

  Attractor (Vec2D loc) {
    super (loc);
    r = 24;
    //[offset-down] The AttractionBehavior &ldquo;distance&rdquo; equals
    // the width so that it covers the entire window.
    physics.addBehavior(new AttractionBehavior(this, width, 0.1));
  }

  void display () {
    fill(0);
    ellipse (x, y, r*2, r*2);
  }
}</pre>

<div data-type="exercise" id="chapter05_exercise16">
<h5>Exercise 5.16</h5>

<p>Create an object that both attracts and repels. What if it attracts any particle that is far away but repels those particles at a short distance?</p>
</div>

<div data-type="exercise" id="chapter05_exercise17">
<h5>Exercise 5.17</h5>

<p>Use <strong klass="">AttractionBehavior</strong> in conjunction with spring forces.</p>
</div>

<div style="page-break-after:always;">&nbsp;</div>

<div data-type="tip">
<h1>The Ecosystem Project</h1>

<p>Step 5 Exercise:</p>

<p>Take your system of creatures from Step 4 and use a physics engine to drive their motion and behaviors. Some possibilities:</p>

<ul>
	<li>
	<p>Use Box2D to allow collisions between creatures. Consider triggering events when creatures collide.</p>
	</li>
	<li>
	<p>Use Box2D to augment the design of your creatures. Build a skeleton with distance joints or make appendages with revolute joints.</p>
	</li>
	<li>
	<p>Use toxiclibs to augment the design of your creature. Use a chain of toxiclibs particles for tentacles or a mesh of springs as a skeleton.</p>
	</li>
	<li>
	<p>Use toxiclibs to add attraction and repulsion behaviors to your creatures.</p>
	</li>
	<li>
	<p>Use spring (or joint) connections between objects to control their interactions. Create and delete these springs on the fly. Consider making these connections visible or invisible to the viewer.</p>
	</li>
</ul>
</div>
</section>
</section>
