Chapter 2.  Forces
------------------

[quote, — Darth Vader]
__________________________________________
“Don't underestimate the Force.”
__________________________________________


((("forces")))

In the final example of Chapter 1, we saw how we could calculate a dynamic acceleration based on a vector pointing from a circle on the screen to the mouse location.   The resulting motion resembled a magnetic attraction between circle and mouse, as if some _force_ were pulling the circle in towards the mouse.  In this chapter we will formalize our understanding of the concept of a force and its relationship to acceleration.    Our goal, by the end of this chapter, is to understand how to make multiple objects move around the screen and respond to a variety of environmental forces.

[[chapter02_section1]]
=== 2.1 Forces and Newton’s Laws of Motion

((("forces","Newton\'s laws of motion")))
((("Newton, Isaac")))

Before we begin examining the practical realities of simulating forces in code, let’s take a conceptual look at what it means to be a force in the real world.   Just like the word “vector,” “force” is often used to mean a variety of things.  It can indicate a powerful intensity, as in “She pushed the boulder with great force” or “He spoke forcefully.”   The definition of *_force_* that we care about is much more formal and comes from Isaac Newton’s laws of motion: 

((("forces","defined")))

[highlight]*A force is a vector that causes an object with mass to accelerate.*

The good news here is that we recognize the first part of the definition: _a force is a vector_. Thank goodness we just spent a whole chapter learning what a vector is and how to program with [klass]*PVector*++s++!   

Let’s look at Newton’s three laws of motion in relation to the concept of a force.

==== Newton’s First Law

((("Newton\'s first law")))

Newton’s first law is commonly stated as:

[highlight]*An object at rest stays at rest and an object in motion stays in motion.*

However, this is missing an important element related to forces. We could expand it by stating:

[highlight]*An object at rest stays at rest and an object in motion stays in motion at a constant speed and direction unless acted upon by an unbalanced force.*

((("Aristotle")))

By the time Newton came along, the prevailing theory of motion—formulated by Aristotle—was nearly two thousand years old. It stated that if an object is moving, some sort of force is required to keep it moving.   Unless that moving thing is being pushed or pulled, it will simply slow down or stop.  Right?

((("equilibrium")))
((("forces","equilibrium")))
((("forces","terminal velocity")))
((("terminal velocity")))

This, of course, is not true.   In the absence of any forces, no force is required to keep an object moving.  An object (such as a ball) tossed in the earth’s atmosphere slows down because of air resistance (a force).    An object’s velocity will only remain constant in the absence of any forces or if the forces that act on it cancel each other out, i.e. the net force adds up to zero.  This is often referred to as *_equilibrium_*.  The falling ball will reach a terminal velocity (that stays constant) once the force of air resistance equals the force of gravity.

[[chapter02_figure1]]
image::imgs/chapter02/ch02_01.png[alt="Figure 2.1: The pendulum doesn't move because all the forces cancel each other out (add up to a net force of zero).",classname="half-width-right"]

In our Processing world, we could restate Newton’s first law as follows:

((("Newton\'s first law","PVector class and")))
((("PVector class (Processing)","Newton\'s first law and")))

[highlight]*An object’s PVector velocity will remain constant if it is in a state of equilibrium.*

Skipping Newton’s second law (arguably the most important law for our purposes) for a moment, let’s move on to the third law.

((("Newton\'s third law")))

==== Newton’s Third Law
This law is often stated as:

[highlight]*For every action there is an equal and opposite reaction.*

This law frequently causes some confusion in the way that it is stated.   For one, it sounds like one force causes another.   Yes, if you push someone, that someone may _actively_ decide to push you back.  But this is not the action and reaction we are talking about with Newton’s third law.  

Let’s say you push against a wall.  The wall doesn’t actively decide to push back on you.   There is no “origin” force.   Your push simply includes both forces, referred to as an “action/reaction pair.”

A better way of stating the law might be: 

[highlight]*Forces always occur in pairs.  The two forces are of equal strength, but in opposite directions.*

Now, this still causes confusion because it sounds like these forces would always cancel each other out.   This is not the case.  Remember, the forces act on different objects.  And just because the two forces are equal, it doesn’t mean that the movements are equal (or that the objects will stop moving).     

Try pushing on a stationary truck.  Although the truck is far more powerful than you, unlike a moving one, a stationary truck will never overpower you and send you flying backwards.  The force you exert on it is equal and opposite to the force exerted on your hands.   The outcome depends on a variety of other factors.  If the truck is a small truck on an icy downhill, you’ll probably be able to get it to move.  On the other hand, if it’s a very large truck on a dirt road and you push hard enough (maybe even take a running start), you could injure your hand.

And if you are wearing roller skates when you push on that truck?

[[chapter02_figure2]]
image::imgs/chapter02/ch02_02.png[alt="Figure 2.2"]

You’ll accelerate away from the truck, sliding along the road while the truck stays put.   Why do you slide but not the truck?  For one, the truck has a much larger mass (which we’ll get into with Newton’s second law).  There are other forces at work too, namely the friction of the truck’s tires and your roller skates against the road. 

==== Newton’s Third Law (as seen through the eyes of Processing)

((("Newton\'s third law","PVector class and")))
((("PVector class (Processing)","Newton\'s third law and")))

[highlight]*If we calculate a PVector f that is a force of object A on object B, we must also apply the force—PVector.mult(f,-1);—that B exerts on object A.*

We’ll see that in the world of Processing programming, we don’t always have to stay true to the above.  Sometimes, such as in the case of see <<chapter02_example6, gravitational attraction between bodies>>, we’ll want to model equal and opposite forces.  Other times, such as when we’re simply saying, “Hey, there’s some wind in the environment,” we’re not going to bother to model the force that a body exerts back on the air.  In fact, we’re not modeling the air at all!  Remember, we are simply taking inspiration from the physics of the natural world, not simulating everything with perfect precision.

[[chapter02_section2]]
=== 2.2 Forces and Processing—Newton’s Second Law as a Function 

((("acceleration","Newton\'s second law")))
((("natural phenomena","Newton\'s second law, modeling")))
((("Newton\'s second law")))

And here we are at the most important law for the Processing programmer.   

==== Newton’s Second Law

This law is stated as:

[highlight]*Force equals mass times acceleration.*

Or:

{newton2a}

Why is this the most important law for us?  Well, let’s write it a different way.

{newton2b}

Acceleration is directly proportional to force and inversely proportional to mass.  This means that if you get pushed, the harder you are pushed, the faster you’ll move (accelerate).  The bigger you are, the slower you’ll move.

((("density")))
((("mass","weight vs.")))
((("weight","mass vs.")))

[NOTE]
.Weight vs. Mass
=====================================================================
- The *_mass_* of an object is a measure of the amount of matter in the object (measured in kilograms).
- *_Weight_*, though often mistaken for mass, is technically the force of gravity on an object. From Newton’s second law, we can calculate it as mass times the acceleration of gravity ([var]*w* = [var]*m* * [var]*g*). Weight is measured in newtons.
- *_Density_* is defined as the amount of mass per unit of volume (grams per cubic centimeter, for example).

Note that an object that has a mass of one kilogram on earth would have a mass of one kilogram on the moon. However, it would weigh only one-sixth as much.
=====================================================================

Now, in the world of Processing, what is mass anyway?  Aren’t we dealing with pixels?  To start in a simpler place, let’s say that in our pretend pixel world, all of our objects have a mass equal to 1.  [var]*F*/ 1 = [var]*F*.  And so:

{aequalsf}

The acceleration of an object is equal to force.  This is great news.  After all, we saw in Chapter 1 that acceleration was the key to controlling the movement of our objects on screen.  Location is adjusted by velocity, and velocity by acceleration.  Acceleration was where it all began.  Now we learn that _force_ is truly where it all begins.

Let’s take our [klass]*Mover* class, with location, velocity, and acceleration.

[source,java]
----
class Mover {
  PVector location;
  PVector velocity;
  PVector acceleration;
}
----

Now our goal is to be able to add forces to this object, perhaps saying:

[source,java]
----
mover.applyForce(wind);
----

or: 

[source,java]
----
mover.applyForce(gravity);
----

where wind and gravity are [klass]*PVector*++s++.  According to Newton’s second law, we could implement this function as follows.

[source,java]
----
void applyForce(PVector force) {
  // Newton’s second law at its simplest.
  acceleration = force;   
}
----

[[chapter02_section3]]
=== 2.3 Force Accumulation

((("forces","accumulation of")))

This looks pretty good.  After all, _acceleration = force_ is a literal translation of Newton’s second law (without mass).  Nevertheless, there’s a pretty big problem here.  Let’s return to what we are trying to accomplish: creating a moving object on the screen that responds to wind and gravity.

[source,java]
----
mover.applyForce(wind);
mover.applyForce(gravity);
mover.update();
mover.display();
----

Ok, let’s _be_ the computer for a moment.  First, we call [function]*applyForce()* with wind.  And so the [klass]*Mover* object’s acceleration is now assigned the [klass]*PVector* [var]*wind*.   Second, we call [function]*applyForce()* with gravity.  Now the [klass]*Mover* object’s acceleration is set to the gravity [klass]*PVector*.    Third, we call [function]*update()*.  What happens in [function]*update()*?  Acceleration is added to velocity.

[source,java]
----
velocity.add(acceleration);
----

We’re not going to see any error in Processing, but zoinks!  We’ve got a major problem.  What is the value of acceleration when it is added to velocity?  It is equal to the gravity force.  Wind has been left out!  If we call [function]*applyForce()* more than once, it overrides each previous call.   How are we going to handle more than one force?

((("force accumulation")))

The answer is through a process known as *_force accumulation_*.  It’s actually very simple; all we need to do is add all of the forces together.  At any given moment, there might be 1, 2, 6, 12, or 303 forces.  As long as our object knows how to accumulate them, it doesn’t matter how many forces act on it.

[source,java]
----
 void applyForce(PVector force) {
  // Newton’s second law, but with force accumulation. 
  // We now add each force to acceleration, one at a time.
    acceleration.add(force);    
 }             
----

Now, we’re not finished just yet.  Force accumulation has one more piece.  Since we’re adding all the forces together at any given moment, we have to make sure that we clear acceleration (i.e. set it to zero) before each time [function]*update()* is called.   Let’s think about wind for a moment.   Sometimes the wind is very strong, sometimes it’s weak, and sometimes there’s no wind at all.   At any given moment, there might be a huge gust of wind, say, when the user holds down the mouse.

[source,java]
----
if (mousePressed) {
  PVector wind = new PVector(0.5,0);
  mover.applyForce(wind);
}
----

((("acceleration","force accumulation and")))

When the user releases the mouse, the wind will stop, and according to Newton’s first law, the object will continue to move at a constant velocity.   However, if we had forgotten to reset acceleration to zero, the gust of wind would still be in effect.  Even worse, it would add onto itself from the previous frame, since we are accumulating forces!    Acceleration, in our simulation, has no memory; it is simply calculated based on the environmental forces present at a moment in time.   This is different than, say, location, which must remember where the object was in the previous frame in order to move properly to the next.   

The easiest way to implement clearing the acceleration for each frame is to multiply the [klass]*PVector* by 0 at the end of [function]*update()*.

[source,java]
----
 void update() {
    velocity.add(acceleration);
    location.add(velocity);
    acceleration.mult(0);
 }
----

[[chapter02_exercise1]]
.Exercise 2.1
==================
Using forces, simulate a helium-filled balloon floating upward and bouncing off the top of a window.  Can you add a wind force that changes over time, perhaps according to Perlin noise?
==================

[[chapter02_section4]]
=== 2.4 Dealing with Mass

((("mass","modeling")))
((("natural phenomena","mass, modeling")))

OK. We’ve got one tiny little addition to make before we are done with integrating forces into our [klass]*Mover* class and are ready to look at examples.  After all, Newton’s second law is really {newton2a}, not {fequalsa}.   Incorporating mass is as easy as adding an instance variable to our class, but we need to spend a little more time here because a slight complication will emerge.

First we just need to add mass.

[source,java]
----
class Mover {
  PVector location;
  PVector velocity;
  PVector acceleration;
  // Adding mass as a float
  float mass;
----

((("mass","units of measurement, defining")))

[NOTE]
.Units of Measurement
=====================================================================
Now that we are introducing mass, it’s important to make a quick note about units of measurement.  In the real world, things are measured in specific units.  We say that two objects are 3 meters apart, the baseball is moving at a rate of 90 miles per hour, or this bowling ball has a mass of 6 kilograms.   As we’ll see later in this book, sometimes we will want to take real-world units into consideration.  However, in this chapter, we’re going to ignore them for the most part.  Our units of measurement are in pixels (“These two circles are 100 pixels apart”) and frames of animation (“This circle is moving at a rate of 2 pixels per frame”).   In the case of mass, there isn’t any unit of measurement for us to use.  We’re just going to make something up.  In this example, we’re arbitrarily picking the number 10.   There is no unit of measurement, though you might enjoy inventing a unit of your own, like “1 moog” or “1 yurkle.”  It should also be noted that, for demonstration purposes, we’ll tie mass to pixels (drawing, say, a circle with a radius of 10).  This will allow us to visualize the mass of an object.   In the real world, however, size does not definitely indicate mass. A small metal ball could have a much higher mass than a large balloon due to its higher density.
=====================================================================

Mass is a scalar (float), not a vector, as it’s just one number describing the amount of matter in an object.  We could be fancy about things and compute the area of a shape as its mass, but it’s simpler to begin by saying, “Hey, the mass of this object is...um, I dunno...how about 10?”

[source,java]
----
 Mover() {
    location = new PVector(random(width),random(height));
    velocity = new PVector(0,0);
    acceleration = new PVector(0,0);
    mass = 10.0;
  }
----

((("forces","applying to objects")))

This isn’t so great since things only become interesting once we have objects with varying mass, but it’ll get us started.  Where does mass come in?  We use it while applying Newton’s second law to our object.

[source,java]
----
 void applyForce(PVector force) {
   //[full] Newton’s second law (with force accumulation and mass)
   force.div(mass);
   acceleration.add(force);   
   //[end]
 }
----

Yet again, even though our code looks quite reasonable, we have a fairly major problem here.  Consider the following scenario with two [klass]*Mover* objects, both being blown away by a wind force.

[source,java]
----
Mover m1 = new Mover();
Mover m2 = new Mover();

PVector wind = new PVector(1,0);

m1.applyForce(wind);
m2.applyForce(wind);
----

Again, let’s _be_ the computer.  Object [var]*m1* receives the wind force—(1,0)—divides it by mass (10), and adds it to acceleration.

[formula]*m1 equals wind force: {nbsp}{nbsp}{nbsp} (1,0)* +
[formula]*Divided by mass of 10: {nbsp}{nbsp} (0.1,0)*

((("object-oriented programming","references to vs. copies of objects")))

OK. Moving on to object [var]*m2*.  It also receives the wind force—(1,0).  Wait.  Hold on a second.  What is the value of the wind force?   Taking a closer look, the wind force is actually now—(0.1,0)!!   Do you remember this little tidbit about working with objects?  When you pass an object (in this case a [klass]*PVector*) into a function, you are passing a reference to that object.  It’s not a copy!  So if a function makes a change to that object (which, in this case, it does by dividing by mass) then that object is permanently changed!  But we don’t want [var]*m2* to receive a force divided by the mass of object [var]*m1*. We want it to receive that force in its original state—(1,0).  And so we must protect ourselves and make a copy of the [klass]*PVector* f before dividing it by mass.    Fortunately, the [klass]*PVector* class has a convenient method for making a copy—[function]*get()*.  [function]*get()* returns a new [klass]*PVector* object with the same data.  And so we can revise [function]*applyForce()* as follows:

[source,java]
----
void applyForce(PVector force) {
  // Making a copy of the PVector before using it!
  PVector f = force.get();
  f.div(mass);
  acceleration.add(f);
}
----

There’s another way we could write the above function, using the static method [function]*div()*. For help with this exercise, review static methods in <<chapter01_section9, Chapter 1>>.

[[chapter02_exercise2]]
.Exercise 2.2
==================
Rewrite the [function]*applyForce()* method using the static method [function]*div()* instead of [function]*get()*. 

[source,java]
----
void applyForce(PVector force) {
  PVector f = _______.___(_____,____);
  acceleration.add(f);
}
----
==================

[[chapter02_section5]]
=== 2.5 Creating Forces

((("forces","creating")))

Let’s take a moment to remind ourselves where we are.  We know what a force is (a vector), and we know how to apply a force to an object (divide it by mass and add it to the object’s acceleration vector).   What are we missing?  Well, we have yet to figure out how we get a force in the first place.  Where do forces come from?

In this chapter, we’ll look at two methods for creating forces in our Processing world.  

((("natural phenomena","forces, modeling")))

. *Make up a force!*  After all, you are the programmer, the creator of your world. There’s no reason why you can’t just make up a force and apply it.
. *Model a force!*  Yes, forces exist in the real world.  And physics textbooks often contain formulas for these forces.  We can take these formulas, translate them into source code, and model real-world forces in Processing.

The easiest way to make up a force is to just pick a number.  Let’s start with the idea of simulating wind.  How about a wind force that points to the right and is fairly weak?  Assuming a [klass]*Mover* object m, our code would look like:

[source,java]
----
  PVector wind = new PVector(0.01,0);
  m.applyForce(wind);
----

The result isn’t terribly interesting, but it is a good place to start.  We create a [klass]*PVector* object, initialize it, and pass it into an object (which in turn will apply it to its own acceleration).  If we wanted to have two forces, perhaps wind and gravity (a bit stronger, pointing down), we might write the following:

image::imgs/chapter02/ch02_ex01.png[canvas="processingjs/chapter02/_2_1_forces/_2_1_forces.pde processingjs/chapter02/_2_1_forces/Mover.pde",classname="screenshot"]

[[chapter02_example1]]
[example]*Example 2.1*

[source,java]
----
  PVector wind = new PVector(0.01,0);
  PVector gravity = new PVector(0,0.1);
  m.applyForce(wind);
  m.applyForce(gravity);
----

Now we have two forces, pointing in different directions with different magnitudes, both applied to object [var]*m*.  We’re beginning to get somewhere.  We’ve now built a world for our objects in Processing, an environment to which they can actually respond.

Let’s look at how we could make this example a bit more exciting with many objects of varying mass.   To do this, we’ll need a quick review of object-oriented programming.  Again, we’re not covering all the basics of programming here (for that you can check out any of the intro Processing books listed in the introduction).  However, since the idea of creating a world filled with objects is pretty fundamental to all the examples in this book, it’s worth taking a moment to walk through the steps of going from one object to many.

This is where we are with the [klass]*Mover* class as a whole.  Notice how it is identical to the [klass]*Mover* class created in Chapter 1, with two additions—[var]*mass* and a new [function]*applyForce()* function.

[source,java]
----
class Mover {

  PVector location;
  PVector velocity;
  PVector acceleration;
  // The object now has mass! 
  float mass;     
           
  Mover() {
    // And for now, we’ll just set the mass equal to 1 for simplicity.
    mass = 1;         
    location = new PVector(30,30);
    velocity = new PVector(0,0);
    acceleration = new PVector(0,0);
  }
  
  // Newton’s second law. 
  void applyForce(PVector force) {
    //[full] Receive a force, divide by mass, and add to acceleration.
    PVector f = PVector.div(force,mass);   
    acceleration.add(f);
    //[end]
  }
  
  void update() {
    //[full] Motion 101 from Chapter 1 
    velocity.add(acceleration);   
    location.add(velocity);
    //[end]
    // Now add clearing the acceleration each time!
    acceleration.mult(0);
  }

  void display() {
    stroke(0);
    fill(175);
    // Let’s scale the size of the object according to its mass.
    ellipse(location.x,location.y,mass*16,mass*16);
  }               

  // Somewhat arbitrarily, we are deciding that an object bounces when it hits the edges of a window.
  void checkEdges() {     
    if (location.x > width) {
      location.x = width;
      velocity.x *= -1;
    } else if (location.x < 0) {
      velocity.x *= -1;
      location.x = 0;
    }

    if (location.y > height) {
      // Even though we said we shouldn't touch location and velocity directly, there are some exceptions.
      // Here we are doing so as a quick and easy way to reverse the direction of our object when it reaches the edge.
      velocity.y *= -1;
      location.y = height;
    }
  }
}
----

Now that our class is set, we can choose to create, say, one hundred [klass]*Mover* objects with an array.

[source,java]
----
Mover[] movers = new Mover[100];
----

And then we can initialize all of those [klass]*Mover* objects in [function]*setup()* with a loop.

[source,java]
----
void setup() {
  for (int i = 0; i < movers.length; i++) {
    movers[i] = new Mover(); 
  }
}
----

But now we have a small issue.  If we refer back to the [klass]*Mover* object’s constructor...

[source,java]
----
  Mover() {
    //[full] Every object has a mass of 1 and a location of (30,30).
    mass = 1;
    location = new PVector(30,30);
    //[end]
    velocity = new PVector(0,0);
    acceleration = new PVector(0,0);
  }
----

((("constructor","arguments, adding to")))

...we discover that every [klass]*Mover* object is made exactly the same way.  What we want are [klass]*Mover* objects of varying mass that start at varying locations.  Here is where we need to increase the sophistication of our constructor by adding arguments.

[source,java]
----
  Mover(float m, float x , float y) {
    //[full] Now setting these variables with arguments
    mass = m;
    location = new PVector(x,y);
    //[end]
    velocity = new PVector(0,0);
    acceleration = new PVector(0,0);
  }
----

Notice how the mass and location are no longer set to hardcoded numbers, but rather initialized via arguments passed through the constructor.   This means we can create a variety of [klass]*Mover* objects: big ones, small ones, ones that start on the left side of the screen, ones that start on the right, etc.

[source,java]
----
// A big Mover on the left side of the window
Mover m1 = new Mover(10,0,height/2);      
// A small Mover on the right side of the window
Mover m1 = new Mover(0.1,width,height/2); 
----

With an array, however, we want to initialize all of the objects with a loop.

[source,java]
----
void setup() {
  for (int i = 0; i < movers.length; i++) {
    // Initializing many Mover objects, all with random mass (and all starting at 0,0)  
    movers[i] = new Mover(random(0.1,5),0,0);  
  }
}
----

For each mover created, the mass is set to a random value between 0.1 and 5, the starting x-location is set to 0, and the starting y-location is set to 0.  Certainly, there are all sorts of ways we might choose to initialize the objects; this is just a demonstration of one possibility.

Once the array of objects is declared, created, and initialized, the rest of the code is simple.  We run through every object, hand them each the forces in the environment, and enjoy the show.

image::imgs/chapter02/ch02_ex02.png[canvas="processingjs/chapter02/_2_2_forces_many/_2_2_forces_many.pde processingjs/chapter02/_2_2_forces_many/Mover.pde",classname="screenshot"]

[[chapter02_example2]]
[example]*Example 2.2*

[source,java]
----
void draw() {
  background(255);

  PVector wind = new PVector(0.01,0);
  // Make up two forces.
  PVector gravity = new PVector(0,0.1);   

  //[full] Loop through all objects and apply both forces to each object.
  for (int i = 0; i < movers.length; i++) {
    movers[i].applyForce(wind);
    movers[i].applyForce(gravity);    
  //[end]
    movers[i].update();
    movers[i].display();
    movers[i].checkEdges();
  }
}
----

Note how in the above image, the smaller circles reach the right of the window faster than the larger ones.  This is because of our formula: _acceleration = force divided by mass_.   The larger the mass, the smaller the acceleration.

[[chapter02_exercise3]]
.Exercise 2.3
==================
Instead of objects bouncing off the edge of the wall, create an example in which an invisible force pushes back on the objects to keep them in the window.  Can you weight the force according to how far the object is from an edge—i.e., the closer it is, the stronger the force?  
==================

[[chapter02_section6]]
=== 2.6 Gravity on Earth and Modeling a Force

((("forces","gravity, modeling")))
((("Galileo")))
((("natural phenomena","forces, modeling","real forces")))
((("natural phenomena","gravity")))

You may have noticed something woefully inaccurate about this last example.  The smaller the circle, the faster it falls.   There is a logic to this; after all, we just stated (according to Newton’s second law) that the smaller the mass, the higher the acceleration.  But this is not what happens in the real world.  If you were to climb to the top of the Leaning Tower of Pisa and drop two balls of different masses, which one will hit the ground first?  According to legend, Galileo performed this exact test in 1589, discovering that they fell with the same acceleration, hitting the ground at the same time.  Why is this?   As we will see later in this chapter, the force of gravity is calculated relative to an object’s mass.  The bigger the object, the stronger the force.  So if the force is scaled according to mass, it is canceled out when acceleration is divided by mass.   We can implement this in our sketch rather easily by multiplying our made-up gravity force by mass.

image::imgs/chapter02/ch02_ex03.png[canvas="processingjs/chapter02/_2_3_forces_many_realgravity/_2_3_forces_many_realgravity.pde processingjs/chapter02/_2_3_forces_many_realgravity/Mover.pde",classname="screenshot"]

[[chapter02_example3]]
[example]*Example 2.3*

[source,java]
----
for (int i = 0; i < movers.length; i++) {

    PVector wind = new PVector(0.001,0);
    float m = movers[i].mass;
    // Scaling gravity by mass to be more accurate
    PVector gravity = new PVector(0,0.1*m);  
    movers[i].applyForce(wind);
    movers[i].applyForce(gravity);

    movers[i].update();
    movers[i].display();
    movers[i].checkEdges();
  }
----

While the objects now fall at the same rate, because the strength of the wind force is independent of mass, the smaller objects still accelerate to the right more quickly.

Making up forces will actually get us quite far.  The world of Processing is a pretend world of pixels and you are its master.  So whatever you deem appropriate to be a force, well by golly, that’s the force it should be.  Nevertheless, there may come a time where you find yourself wondering: “But how does it really all work?”  

((("forces","models of, building")))
((("natural phenomena","physics (real world), modeling")))
((("physics","modeling")))

Open up any high school physics textbook and you will find some diagrams and formulas describing many different forces—gravity, electromagnetism, friction, tension, elasticity, and more.  In this chapter we’re going to look at two forces—friction and gravity.  The point we’re making here is not that friction and gravity are fundamental forces that you always need to have in your Processing sketches.  Rather, we want to evaluate these two forces as case studies for the following process:

- Understanding the concept behind a force
- Deconstructing the force’s formula into two parts:
  * How do we compute the force’s direction?
  * How do we compute the force’s magnitude?
- Translating that formula into Processing code that calculates a [klass]*PVector* to be sent through our [klass]*Mover*++'s++ [function]*applyForce()* function

If we can follow the above steps with two forces, then hopefully if you ever find yourself Googling “atomic nuclei weak nuclear force” at 3 a.m., you will have the skills to take what you find and adapt it for Processing.

((("formulae, evaluating in code")))

[NOTE]
.Dealing with formulae
=====================================================================
OK, in a moment we’re going to write out the formula for friction.  This isn’t the first time we’ve seen a formula in this book; we just finished up our discussion of Newton’s second law, {newton2a} (or force = mass * acceleration).    We didn’t spend a lot of time worrying about this formula because it’s a nice and simple one.  Nevertheless, it’s a scary world out there.  Just take a look at the equation for a “normal” distribution, which we covered (without looking at the formula) in the <<intro_section4, Introduction>>.

{normal}

((("friction","formula for")))

What we’re seeing here is that formulas like to use a lot of symbols (quite often letters from the Greek alphabet).   Let’s take a look at the formula for friction.

{friction1}

If it’s been a while since you’ve looked at a formula from a math or physics textbook, there are three key points that are important to cover before we move on.

- *_Evaluate the right side, assign to the left side._*  This is just like in code!  What we’re doing here is evaluating the right side of the equation and assigning it to the left.  In the case above, we want to calculate the force of friction—the left side tells us what we want to calculate and the right side tells us how to do it.
- *_Are we talking about a vector or a scalar?_*  It’s important for us to realize that in some cases, we’ll be looking at a vector; in others, a scalar.   For example, in this case the force of friction is a vector.  We can see that by the arrow above the word “friction.” It has a magnitude and direction.  The right side of the equation also has a vector, as indicated by the symbol {unitv}, which in this case stands for the velocity unit vector.
- *_When symbols are placed next to each other, we mean for them to be multiplied._*  The formula above actually has four elements:  -1, _μ_, _N_, and {unitv}.  We want to multiply them together and read the formula as: {friction2}
=====================================================================

[[chapter02_section7]]
=== 2.7 Friction

((("forces","friction, modeling")))
((("friction","modeling with formulae")))
((("natural phenomena","friction")))

Let’s begin with friction and follow our steps.

((("dissipative force")))

Friction is a *_dissipative force_*.  A dissipative force is one in which the total energy of a system decreases when an object is in motion.   Let’s say you are driving a car. When you press your foot down on the brake pedal, the car’s brakes use friction to slow down the motion of the tires.  Kinetic energy (motion) is converted into thermal energy (heat).   Whenever two surfaces come into contact, they experience friction.   A complete model of friction would include separate cases for static friction (a body at rest against a surface) and kinetic friction (a body in motion against a surface), but for our purposes, we are only going to look at the kinetic case.

Here's the formula for friction:

[[chapter02_figure3]]
image::imgs/chapter02/ch02_03.png[alt="Figure 2.3"]

((("friction","determining direction/magnitude of")))

It’s now up to us to separate this formula into two components that determine the direction of friction as well as the magnitude.  Based on the diagram above, we can see that _friction points in the opposite direction of velocity._   In fact, that’s the part of the formula that says -1 * {unitv}, or -1 times the velocity unit vector.  In Processing, this would mean taking the velocity vector, normalizing it, and multiplying by -1.  

[source,java]
----
PVector friction = velocity.get();
friction.normalize();
// Let’s figure out the direction of the friction force 
// (a unit vector in the opposite direction of velocity). 
friction.mult(-1);
----

Notice two additional steps here.  First, it’s important to make a copy of the velocity vector, as we don’t want to reverse the object’s direction by accident.  Second, we normalize the vector.  This is because the magnitude of friction is not associated with how fast it is moving, and we want to start with a friction vector of magnitude 1 so that it can easily be scaled.

((("μ (mu)")))
((("μ (mu)")))
((("coefficient of friction")))
((("coefficient of friction","μ (mu)")))
((("friction","μ (mu)")))
((("friction","coefficient of friction")))

According to the formula, the magnitude is [var]*μ* * [var]*N*.   [var]*μ*, the Greek letter _mu_ (pronounced “mew”), is used here to describe the *_coefficient of friction_*.   The coefficient of friction establishes the strength of a friction force for a particular surface.  The higher it is, the stronger the friction; the lower, the weaker.   A block of ice, for example, will have a much lower coefficient of friction than, say, sandpaper.   Since we’re in a pretend Processing world, we can arbitrarily set the coefficient based on how much friction we want to simulate.

[source,java]
----
float c = 0.01;
----

((("friction","normal force")))
((("normal force")))

Now for the second part: [var]*N*.  [var]*N* refers to the *_normal force_*, the force perpendicular to the object’s motion along a surface.  Think of a vehicle driving along a road.   The vehicle pushes down against the road with gravity, and Newton’s third law tells us that the road in turn pushes back against the vehicle.  That’s the normal force.  The greater the gravitational force, the greater the normal force.   As we’ll see in the next section, gravity is associated with mass, and so a lightweight sports car would experience less friction than a massive tractor trailer truck.   With the diagram above, however, where the object is moving along a surface at an angle, computing the normal force is a bit more complicated because it doesn’t point in the same direction as gravity.  We’ll need to know something about angles and trigonometry. 

All of these specifics are important; however, in Processing, a “good enough” simulation can be achieved without them.  We can, for example, make friction work with the assumption that the normal force will always have a magnitude of 1.  When we get into trigonometry in the next chapter, we’ll remember to return to this question and make our friction example a bit more sophisticated.  Therefore:

[source,java]
----
float normal = 1;
----

Now that we have both the magnitude and direction for friction, we can put it all together...

[source,java]
----
float c = 0.01;
float normal = 1;
// Let’s figure out the magnitude of friction 
// (really just an arbitrary constant).
float frictionMag = c*normal; 

PVector friction = velocity.get();
friction.mult(-1); 
friction.normalize();

// Take the unit vector and multiply it by magnitude 
// and we have our force vector!
friction.mult(frictionMag);
----

...and add it to our “forces” example, where many objects experience wind, gravity, and now friction:

image::imgs/chapter02/ch02_ex04a.png[canvas="processingjs/chapter02/_2_4_forces_nofriction/_2_4_forces_nofriction.pde processingjs/chapter02/_2_4_forces_nofriction/Mover.pde",alt="No friction",classname="two-col"]

image::imgs/chapter02/ch02_ex04b.png[canvas="processingjs/chapter02/_2_4_forces_friction/_2_4_forces_friction.pde processingjs/chapter02/_2_4_forces_friction/Mover.pde",alt="With friction",classname="two-col"]

[[chapter02_example4]]
[example]*Example 2.4: Including friction*

[source,java]
----
void draw() {
  background(255);

  PVector wind = new PVector(0.001,0);
  // We could scale by mass to be more accurate.
  PVector gravity = new PVector(0,0.1); 

  for (int i = 0; i < movers.length; i++) {

    float c = 0.01; //[bold]
    PVector friction = movers[i].velocity.get(); //[bold]
    friction.mult(-1); //[bold]
    friction.normalize(); //[bold]
    friction.mult(c); //[bold]

    // Apply the friction force vector to the object.
    movers[i].applyForce(friction); //[bold]
    movers[i].applyForce(wind);
    movers[i].applyForce(gravity);

    movers[i].update();
    movers[i].display();
    movers[i].checkEdges();
  }

}
----

Running this example, you’ll notice that the circles don’t even make it to the right side of the window.  Since friction continuously pushes against the object in the opposite direction of its movement, the object continuously slows down.  This can be a useful technique or a problem depending on the goals of your visualization.

[[chapter02_exercise4]]
.Exercise 2.4
==================
Create pockets of friction in a Processing sketch so that objects only experience friction when crossing over those pockets.    What if you vary the strength (friction coefficient) of each area?   What if you make some pockets feature the opposite of friction—i.e., when you enter a given pocket you actually speed up instead of slowing down?
==================

[[chapter02_section8]]
=== 2.8 Air and Fluid Resistance

[[chapter02_figure4]]
image::imgs/chapter02/ch02_04.png[alt="Figure 2.4"]

((("drag force")))
((("fluid resistance, modeling")))
((("forces","fluid resistance")))
((("natural phenomena","fluid resistance, modeling")))
((("viscous force")))

Friction also occurs when a body passes through a liquid or gas.  This force has many different names, all really meaning the same thing: _viscous force_, _drag force_, _fluid resistance_.  While the result is ultimately the same as our previous friction examples (the object slows down), the way in which we calculate a drag force will be slightly different.  Let’s look at the formula:

{drag1}

Now let’s break this down and see what we really need for an effective simulation in Processing, making ourselves a much simpler formula in the process.

- {Fd} refers to _drag force_, the vector we ultimately want to compute and pass into our [function]*applyForce()* function.
- - 1/2 is a constant: -0.5.   This is fairly irrelevant in terms of our Processing world, as we will be making up values for other constants anyway.   However, the fact that it is negative is important, as it tells us that the force is in the opposite direction of velocity (just as with friction).

((("ρ (rho)")))
((("friction","ρ (rho)")))

- {rho} is the Greek letter _rho_, and refers to the density of the liquid, something we don’t need to worry about.  We can simplify the problem and consider this to have a constant value of 1.
- {v} refers to the speed of the object moving.  OK, we’ve got this one!  The object’s speed is the magnitude of the velocity vector:  [function]*velocity.magnitude()*.  And {v2} just means {v} squared or {v} * {v}.
- {A} refers to the frontal area of the object that is pushing through the liquid (or gas).  An aerodynamic Lamborghini, for example, will experience less air resistance than a boxy Volvo.   Nevertheless, for a basic simulation, we can consider our object to be spherical and ignore this element.
- {Cd} is the coefficient of drag, exactly the same as the coefficient of friction ({rho}).  This is a constant we’ll determine based on whether we want the drag force to be strong or weak.
- {unitv} Look familiar?  It should.  This refers to the velocity unit vector, i.e. [function]*velocity.normalize()*.  Just like with friction, drag is a force that points in the opposite direction of velocity.

Now that we’ve analyzed each of these components and determined what we need for a simple simulation, we can reduce our formula to:

[[chapter02_figure5]]
image::imgs/chapter02/ch02_05.png[alt="Figure 2.5: Our simplified drag force formula"]

or:

[source,java]
----
float c = 0.1;
float speed = v.mag();
// Part 1 of our formula (magnitude): Cd * v2
float dragMagnitude = c * speed * speed;  
PVector drag = velocity.get();
// Part 2 of our formula (direction): 
// -1 * velocity
drag.mult(-1);
drag.normalize();
// Magnitude and direction together!
drag.mult(dragMagnitude);
----

((("friction","applying to an object")))

Let’s implement this force in our [klass]*Mover* class example with one addition.   When we wrote our friction example, the force of friction was always present.  Whenever an object was moving, friction would slow it down.  Here, let’s introduce an element to the environment—a “liquid” that the [klass]*Mover* objects pass through.  The [klass]*Liquid* object will be a rectangle and will know about its location, width, height, and “coefficient of drag”—i.e., is it easy for objects to move through it (like air) or difficult (like molasses)?  In addition, it should include a function to draw itself on the screen (and two more functions, which we’ll see in a moment).

[source,java]
----
class Liquid {
  // The liquid object includes a variable defining
  // its coefficient of drag.
  float x,y,w,h;
  float c;  

  Liquid(float x_, float y_, float w_, float h_, float c_) {
    x = x_;
    y = y_;
    w = w_;
    h = h_;
    c = c_;
  }

  void display() {
    noStroke();
    fill(175);
    rect(x,y,w,h);
  }

}
----

The main program will now include a [klass]*Liquid* object reference as well as a line of code that initializes that object.

[source,java]
----
Liquid liquid;

void setup() {
  //[offset-up] Initialize a Liquid object.  Note that the coefficient value is low (0.1), otherwise the object would come to a halt fairly quickly (which may someday be the effect you want).
  liquid = new Liquid(0, height/2, width, height/2, 0.1); 
}             
----

Now comes an interesting question: how do we get the [klass]*Mover* object to talk to the [klass]*Liquid* object?  In other words, we want to execute the following:

_When a mover passes through a liquid it experiences a drag force._

...or in object-oriented speak (assuming we are looping through an array of [klass]*Mover* objects with index i):

[source,java]
----
if (movers[i].isInside(liquid)) {
  // If a Mover is inside a Liquid, apply the drag force.
  movers[i].drag(liquid);   
}
----

The above code tells us that we need to add two functions to the [klass]*Mover* class: (1) a function that determines if a [klass]*Mover* object is inside the [klass]*Liquid* object, and (2) a function that computes and applies a drag force on the [klass]*Mover* object.

The first is easy; we can simply use a conditional statement to determine if the location vector rests inside the rectangle defined by the liquid.

[source,java]
----
boolean isInside(Liquid l) {
  //[offset-down] This conditional statement determines if the PVector location is inside the rectangle defined by the Liquid class.
  if (location.x>l.x && location.x<l.x+l.w && location.y>l.y && location.y<l.y+l.h) {
    return true;    
  } else {         
    return false;
  }
}
----

The [function]*drag()* function is a bit more complicated; however, we’ve written the code for it already.  This is simply an implementation of our formula.  The drag force is equal to _the coefficient of drag multiplied by the speed of the [klass]*Mover* squared in the opposite direction of velocity!_

[source,java]
----
 void drag(Liquid l) {
    
    float speed = velocity.mag();
    // The force’s magnitude: Cd * v~2~
    float dragMagnitude = l.c * speed * speed;
                 
    PVector drag = velocity.get();
    drag.mult(-1);
    // The force's direction: -1 * velocity
    drag.normalize();       

    // Finalize the force: magnitude and direction together.
    drag.mult(dragMagnitude);     
    
    // Apply the force.
    applyForce(drag);       
  }
----

And with these two functions added to the [klass]*Mover* class, we’re ready to put it all together in the main tab:

image::imgs/chapter02/ch02_ex05.png[canvas="processingjs/chapter02/_2_5_fluidresistance/_2_5_fluidresistance.pde processingjs/chapter02/_2_5_fluidresistance/Liquid.pde processingjs/chapter02/_2_5_fluidresistance/Mover.pde",classname="screenshot"]

[[chapter02_example5]]
[example]*Example 2.5: Fluid Resistance*

[source,java]
----
Mover[] movers = new Mover[100];

Liquid liquid;

void setup() {
  size(360, 640);
  smooth();
  for (int i = 0; i < movers.length; i++) {
    movers[i] = new Mover(random(0.1,5),0,0); 
  }
  liquid = new Liquid(0, height/2, width, height/2, 0.1);
}

void draw() {
  background(255);

  liquid.display();

  for (int i = 0; i < movers.length; i++) {

    if (movers[i].isInside(liquid)) {
      movers[i].drag(liquid);
    }

    float m = 0.1*movers[i].mass;
    // Note that we are scaling gravity according to mass.
    PVector gravity = new PVector(0, m); 
    movers[i].applyForce(gravity);

    movers[i].update();
    movers[i].display();
    movers[i].checkEdges();
  }
}
----

Running the example, you should notice that we are simulating balls falling into water.  The objects only slow down when crossing through the gray area at the bottom of the window (representing the liquid).  You’ll also notice that the smaller objects slow down a great deal more than the larger objects.    Remember Newton’s second law?  [var]*A* = [var]*F* / [var]*M*. Acceleration equals force _divided_ by mass.  A massive object will accelerate less.  A smaller object will accelerate more.    In this case, the acceleration we’re talking about is the “slowing down” due to drag.  The smaller objects will slow down at a greater rate than the larger ones.

[[chapter02_exercise5]]
.Exercise 2.5
==================
Take a look at our formula for drag again:  *_drag force = coefficient * speed * speed_*.  The faster an object moves, the greater the drag force against it.  In fact, an object not moving in water experiences no drag at all.   Expand the example to drop the balls from different heights.  How does this affect the drag as they hit the water?
==================

[[chapter02_exercise6]]
.Exercise 2.6
==================
The formula for drag also included surface area.  Can you create a simulation of boxes falling into water with a drag force dependent on the length of the side hitting the water?
==================

[[chapter02_exercise7]]
.Exercise 2.7
==================
Fluid resistance does not only work opposite to the velocity vector, but also perpendicular to it.  This is known as “lift-induced drag” and will cause an airplane with an angled wing to rise in altitude.   Try creating a simulation of lift. 
==================

[[chapter02_section9]]
=== 2.9 Gravitational Attraction

((("gravity","modeling")))
((("natural phenomena","gravity")))

[[chapter02_figure6]]
image::imgs/chapter02/ch02_06.png[alt="Figure 2.6",classname="half-width-right"]

Probably the most famous force of all is gravity.   We humans on earth think of gravity as an apple hitting Isaac Newton on the head.    Gravity means that stuff falls down.  But this is only _our_ experience of gravity.   In truth, just as the earth pulls the apple towards it due to a gravitational force, the apple pulls the earth as well.   The thing is, the earth is just so freaking big that it overwhelms all the other gravity interactions.  Every object with mass exerts a gravitational force on every other object.   And there is a formula for calculating the strengths of these forces, as depicted in Figure 2.6.

Let’s examine this formula a bit more closely.

((("forces","universal gravitational constant")))
((("gravity","universal gravitational constant")))
((("universal gravitational constant")))

- [var]*F* refers to the gravitational force, the vector we ultimately want to compute and pass into our [function]*applyForce()* function.
- [var]*G* is the _universal gravitational constant_, which in our world equals 6.67428 x 10^-11^ meters cubed per kilogram per second squared.   This is a pretty important number if your name is Isaac Newton or Albert Einstein.  It’s not an important number if you are a Processing programmer.  Again, it’s a constant that we can use to make the forces in our world weaker or stronger.  Just making it equal to one and ignoring it isn’t such a terrible choice either.
- [var]*m~1~* and [var]*m~2~* are the masses of objects 1 and 2.   As we saw with Newton’s second law ({newton2a}), mass is also something we could choose to ignore.  After all, shapes drawn on the screen don’t actually have a physical mass.  However, if we keep these values, we can create more interesting simulations in which “bigger” objects exert a stronger gravitational force than smaller ones.
- {unitr} refers to the unit vector pointing from object 1 to object 2.  As we’ll see in a moment, we can compute this direction vector by subtracting the location of one object from the other.
- [var]*r*^2^ refers to the distance between the two objects squared.  Let’s take a moment to think about this a bit more.  With everything on the top of the formula—[var]*G*, [var]*m~1~*, [var]*m~2~*+++—+++the bigger its value, the stronger the force.  Big mass, big force.  Big [var]*G*, big force.  Now, when we divide by something, we have the opposite.  The strength of the force is inversely proportional to the distance squared.  The _farther away_ an object is, the _weaker_ the force; the _closer_, the _stronger_.   

Hopefully by now the formula makes some sense to us.  We’ve looked at a diagram and dissected the individual components of the formula.  Now it’s time to figure out how we translate the math into Processing code.  Let’s make the following assumptions.

We have two objects, and:

((("gravity","implementing model of")))
((("natural phenomena","gravity")))

. Each object has a location: [var]*PVector location1* and [var]*PVector location2*.
. Each object has a mass: [var]*float mass1* and [var]*float mass2*.
. There is a variable [var]*float G* for the universal gravitational constant.

Given these assumptions, we want to compute [var]*PVector force*, the force of gravity.  We’ll do it in two parts.  First, we’ll compute the direction of the force {unitr} in the formula above.  Second, we’ll calculate the strength of the force according to the masses and distance.

[[chapter02_figure7]]
image::imgs/chapter02/ch02_07.png[alt="Figure 2.7",classname="half-width-right"]

Remember in <<chapter01_section10, Chapter 1>>, when we figured out how to have an object accelerate towards the mouse? (See Figure 2.7.)

A vector is the difference between two points. To make a vector that points from the circle to the mouse, we simply subtract one point from another:

[source,java]
----
PVector dir = PVector.sub(mouse,location);
----

In our case, the direction of the attraction force that object 1 exerts on object 2 is equal to:

[source,java]
----
PVector dir = PVector.sub(location1,location2);
dir.normalize();
----

Don’t forget that since we want a unit vector, a vector that tells us about direction only, we’ll need to _normalize_ the vector after subtracting the locations.

OK, we’ve got the direction of the force.  Now we just need to compute the magnitude and scale the vector accordingly.  

[source,java]
----
float m = (G * mass1 * mass2) / (distance * distance);
dir.mult(m);
----

[[chapter02_figure8]]
image::imgs/chapter02/ch02_08.png[alt="Figure 2.8",classname="half-width-right"]

The only problem is that we don’t know the distance.  [var]*G*, [var]*mass1*, and [var]*mass2* were all givens, but we’ll need to actually compute distance before the above code will work.   Didn’t we just make a vector that points all the way from one location to another?   Wouldn’t the length of that vector be the distance between two objects?   

Well, if we add just one line of code and grab the magnitude of that vector before normalizing it, then we’ll have the distance.

[source,java]
----
// The vector that points from one object to another
PVector force = PVector.sub(location1,location2); 

// The length (magnitude) of that vector is the distance between the two objects.
float distance = force.magnitude();       

// Use the formula for gravity to compute the strength of the force.
float m = (G * mass1 * mass2) / (distance * distance); 

// Normalize and scale the force vector 
// to the appropriate magnitude.
force.normalize();      
force.mult(m);           
----

Note that I also renamed the [klass]*PVector* “dir” as “force.”   After all, when we’re finished with the calculations, the [klass]*PVector* we started with ends up being the actual force vector we wanted all along.  

Now that we’ve worked out the math and the code for calculating an attractive force (emulating gravity), we need to turn our attention to applying this technique in the context of an actual Processing sketch.   In Example 2.1, you may recall how we created a simple [klass]*Mover* object—a class with [klass]*PVector*++’s++ location, velocity, and acceleration as well as an [function]*applyForce()*.  Let’s take this exact class and put it in a sketch with:

[[chapter02_figure9]]
image::imgs/chapter02/ch02_09.png[classname="half-width-right",alt="Figure 2.9"]

- A single [klass]*Mover* object.
- A single [klass]*Attractor* object (a new class that will have a fixed location).

The [klass]*Mover* object will experience a gravitational pull towards the [klass]*Attractor* object, as illustrated in Figure 2.9.

We can start by making the new [klass]*Attractor* class very simple—giving it a location and a mass, along with a function to display itself (tying mass to size).

[source,java]
----
class Attractor {
  // Our Attractor is a simple object that doesn’t move. 
  // We just need a mass and a location.  
  float mass;       
  PVector location;    

  Attractor() {
    location = new PVector(width/2,height/2);
    mass = 20;
  }

  void display() {
    stroke(0);
    fill(175,200);
    ellipse(location.x,location.y,mass*2,mass*2);
  }
}
----

And in our main program, we can add an instance of the [klass]*Attractor* class.

[source,java]
----
Mover m;
Attractor a;

void setup() {
  size(200,200);
  m = new Mover(); 
  // Initialize Attractor object.
  a = new Attractor();    
}

void draw() {
  background(255);

  // Display Attractor object.
  a.display();

  m.update();
  m.display();
}
----

((("object","interaction between")))

This is a good structure: a main program with a [klass]*Mover* and an [klass]*Attractor* object, and a class to handle the variables and behaviors of movers and attractors.   The last piece of the puzzle is how to get one object to attract the other.  How do we get these two objects to talk to each other?

There are a number of ways we could do this.  Here are just a few possibilities.

++++
<table class="code">
<tr>
<th>Task</th>
<th>Function</th>
</tr>
<tr>
<td>1. A function that receives both an Attractor and a Mover:</td>
<td><pre>attraction(a,m);</pre></td>
</tr>
<tr>
<td>2. A function in the Attractor class that receives a Mover:</td>
<td><pre>a.attract(m);</pre></td>
</tr>
<tr>
<td>3. A function in the Mover class that receives an Attractor:</td>
<td><pre>m.attractedTo(a);</pre></td>
</tr>
<tr>
<td>4. A function in the Attractor class that receives a Mover and returns a PVector, which is the attraction force.  That attraction force is then passed into the Mover's applyForce() function:</td>
<td>
<pre>
PVector f = a.attract(m);
m.applyForce(f);
</pre></td>
</tr>
</table>
++++

and so on. . .

It’s good to look at a range of options for making objects talk to each other, and you could probably make arguments for each of the above possibilities.  I’d like to at least discard the first one, since an object-oriented approach is really a much better choice over an arbitrary function not tied to either the [klass]*Mover* or [klass]*Attractor* class.   Whether you pick option 2 or option 3 is the difference between saying “The attractor attracts the mover” or “The mover is attracted to the attractor.”  Number 4 is really my favorite, at least in terms of where we are in this book.  After all, we spent a lot of time working out the [function]*applyForce()* function, and I think our examples will be clearer if we continue with the same methodology.

In other words, where we once had:

[source,java]
----
// Made-up force
PVector f = new PVector(0.1,0);
m.applyForce(f);
----

We now have:

[source,java]
----
// Attraction force between two objects
PVector f = a.attract(m); //[bold]
m.applyForce(f);
----

And so our [function]*draw()* function can now be written as:

[source,java]
----
void draw() {
  background(255);

  //[full] Calculate attraction force and apply it.
  PVector f = a.attract(m); //[bold]
  m.applyForce(f); //[bold]
  //[end]

  m.update();

  a.display();
  m.display();

}
----

We’re almost there.  Since we decided to put the [function]*attract()* function inside of the [klass]*Attractor* class, we’ll need to actually write that function.   The function needs to receive a [klass]*Mover* object and return a [klass]*PVector*, i.e.:

[source,java]
----
PVector attract(Mover m) {

}
----

And what goes inside that function?  All of that nice math we worked out for gravitational attraction!

[source,java]
----
PVector attract(Mover m) {
  
  // What’s the force’s direction?
  PVector force = PVector.sub(location,m.location);
  float distance = force.mag();
  force.normalize();
  //[offset-down] What’s the force’s magnitude?
  float strength = (G * mass * m.mass) / (distance * distance); 
  force.mult(strength);
  
  // Return the force so that it can be applied!
  return force;   
}
----

((("gravity","placing limits on model of")))

And we’re done.  Sort of.  Almost.  There’s one small kink we need to work out.  Let’s look at the above code again.  See that symbol for divide, the slash?  Whenever we have one of these, we need to ask ourselves the question:  What would happen if  the distance happened to be a really, really small number or (even worse!) zero??!  Well, we know we can’t divide a number by 0, and if we were to divide a number by something like 0.0001, that is the equivalent of multiplying that number by 10,000!   Yes, this is the real-world formula for the strength of gravity, but we don’t live in the real world.  We live in the _Processing_ world.   And in the Processing world, the mover could end up being very, very close to the attractor and the force could become so strong the mover would just fly way off the screen.   And so with this formula, it’s good for us to be practical and constrain the range of what [var]*distance* can actually be.   Maybe, no matter where the [klass]*Mover* actually is, we should never consider it less than 5 pixels or more than 25 pixels away from the attractor.

[source,java]
----
  distance = constrain(distance,5,25);
----

For the same reason that we need to constrain the minimum distance, it’s useful for us to do the same with the maximum.  After all, if the mover were to be, say, 500 pixels from the attractor (not unreasonable), we’d be dividing the force by 250,000.  That force might end up being so weak that it’s almost as if we’re not applying it at all.

Now, it’s really up to you to decide what behaviors you want.  But in the case of, “I want reasonable-looking attraction that is never absurdly weak or strong,” then constraining the distance is a good technique.

Our [klass]*Mover* class hasn’t changed at all, so let’s just look at the main program and the [klass]*Attractor* class as a whole, adding a variable [var]*G* for the universal gravitational constant.  (On the website, you’ll find that this example also has code that allows you to move the [klass]*Attractor* object with the mouse.)

image::imgs/chapter02/ch02_ex06.png[canvas="processingjs/chapter02/_2_6_attraction/_2_6_attraction.pde processingjs/chapter02/_2_6_attraction/Attractor.pde processingjs/chapter02/_2_6_attraction/Mover.pde",classname="screenshot"]

[[chapter02_example6]]
[example]*Example 2.6: Attraction*

[source,java]
----
// A Mover and an Attractor
Mover m;
Attractor a;

void setup() {
  size(200,200);
  m = new Mover(); 
  a = new Attractor();
}

void draw() {
  background(255);

  // Apply the attraction force from the Attractor on the Mover.
  PVector force = a.attract(m); 
  m.applyForce(force);         
  m.update();
 
  a.display();
  m.display();
}

class Attractor {
  float mass;               
  PVector location;   
  float G;

  Attractor() {
    location = new PVector(width/2,height/2);
    mass = 20;
    G = 0.4;
  }

  PVector attract(Mover m) {
    PVector force = PVector.sub(location,m.location);             
    float distance = force.mag();                                 
    // Remember, we need to constrain the distance 
    // so that our circle doesn’t spin out of control.
    distance = constrain(distance,5.0,25.0);


    force.normalize();                                         
    float strength = (G * mass * m.mass) / (distance * distance); 
    force.mult(strength);                                         
    return force;
  }

  void display() {
    stroke(0);
    fill(175,200);
    ellipse(location.x,location.y,mass*2,mass*2);
  }
}
----

And we could, of course, expand this example using an array to include many [klass]*Mover* objects, just as we did with friction and drag:

image::imgs/chapter02/ch02_ex07.png[canvas="processingjs/chapter02/_2_7_attraction_many/_2_7_attraction_many.pde processingjs/chapter02/_2_7_attraction_many/Attractor.pde processingjs/chapter02/_2_7_attraction_many/Mover.pde",classname="screenshot"]

[[chapter02_example7]]
[example]*Example 2.7: Attraction with many Movers*

[source,java]
----
// Now we have 10 Movers!
Mover[] movers = new Mover[10];

Attractor a;

void setup() {
  size(400,400);
  for (int i = 0; i < movers.length; i++) {
    //[offset-down] Each Mover is initialized randomly.
    movers[i] = new Mover(random(0.1,2),random(width),random(height)); 
  }       
  a = new Attractor();
}

void draw() {
  background(255);

  a.display();

  for (int i = 0; i < movers.length; i++) {
    // We calculate an attraction force for each Mover object.
    PVector force = a.attract(movers[i]);
    movers[i].applyForce(force);

    movers[i].update();
    movers[i].display();
  }

}
----

[[chapter02_exercise8]]
.Exercise 2.8
==================
In the example above, we have a system (i.e. array) of [klass]*Mover* objects and one [klass]*Attractor* object.  Build an example that has systems of both movers and attractors.  What if you make the attractors invisible?  Can you create a pattern/design from the trails of objects moving around attractors?  (See the Metropop Denim project by Clayton Cubitt and Tom Carden: http://processing.org/exhibition/works/metropop/ for an example.) 
==================

[[chapter02_exercise9]]
.Exercise 2.9
==================
It’s worth noting that gravitational attraction is a model we can follow to develop our own forces.  This chapter isn’t suggesting that you should exclusively create sketches that use gravitational attraction.  Rather, you should be thinking creatively about how to design your own rules to drive the behavior of objects.  For example, what happens if you design a force that is weaker the closer it gets and stronger the farther it gets?  Or what if you design your attractor to attract faraway objects, but repel close ones?
==================

[[chapter02_section10]]
=== 2.10 Everything Attracts (or Repels) Everything

Hopefully, you found it helpful that we started with a simple scenario—_one object attracts another object_++—++and moved on to _one object attracts many objects_.  However, it’s likely that you are going to find yourself in a slightly more complex situation: _many objects attract each other_.  In other words, every object in a given system attracts every other object in that system (except for itself).

We’ve really done almost all of the work for this already.  Let’s consider a Processing sketch with an array of [klass]*Mover* objects:

[source,java]
----
Mover[] movers = new Mover[10];

void setup() {
  size(400,400);
  for (int i = 0; i < movers.length; i++) {
    movers[i] = new Mover(random(0.1,2),random(width),random(height)); 
  }
}

void draw() {
  background(255);
  for (int i = 0; i < movers.length; i++) {
    movers[i].update();
    movers[i].display();
  }
}
----

The [function]*draw()* function is where we need to work some magic.  Currently, we’re saying: “for every mover [var]*i*, update and display yourself.”  Now what we need to say is: “for every mover [var]*i*, be attracted to every other mover [var]*j*, and update and display yourself.”

To do this, we need to nest a second loop.

[source,java]
----
 for (int i = 0; i < movers.length; i++) {
  // For every Mover, check every Mover!
    for (int j = 0; j < movers.length; j++) {   
      PVector force = movers[j].attract(movers[i]);      
      movers[i].applyForce(force);
    }
    movers[i].update();
    movers[i].display();
  }
----

In the previous example, we had an [klass]*Attractor* object with a function named [function]*attract()*.  Now, since we have movers attracting movers, all we need to do is copy the [function]*attract()* function into the [klass]*Mover* class.

[source,java]
----
class Mover {

  [inline]// All the other stuff we had before plus. . .

  // The Mover now knows how to attract another Mover.
  PVector attract(Mover m) {

    PVector force = PVector.sub(location,m.location);                  
    float distance = force.mag();                                 
    distance = constrain(distance,5.0,25.0);                            
    force.normalize();                                           

    float strength = (G * mass * m.mass) / (distance * distance); 
    force.mult(strength); 
    return force;
  }
}
----

Of course, there’s one small problem. When we are looking at every mover [var]*i* and every mover [var]*j*, are we OK with the times that [var]*i* equals [var]*j*?  For example, should mover #3 attract mover #3?   The answer, of course, is no.   If there are five objects, we only want mover #3 to attract 0, 1, 2, and 4, skipping itself.   And so, we finish this example by adding a simple conditional statement to skip applying the force when i equals j.

image::imgs/chapter02/ch02_ex08.png[canvas="processingjs/chapter02/_2_8_mutual_attraction/_2_8_mutual_attraction.pde processingjs/chapter02/_2_8_mutual_attraction/Mover.pde",classname="screenshot"]

[[chapter02_example8]]
[example]*Example 2.8: Mutual attraction*

[source,java]
----
Mover[] movers = new Mover[20];

float g = 0.4;

void setup() {
  size(400,400);
  for (int i = 0; i < movers.length; i++) {
    movers[i] = new Mover(random(0.1,2),random(width),random(height)); 
  }
}

void draw() {
  background(255);

  for (int i = 0; i < movers.length; i++) {
    for (int j = 0; j < movers.length; j++) {
      // Don’t attract yourself!
      if (i != j) {           
        PVector force = movers[j].attract(movers[i]);
        movers[i].applyForce(force);
      }
    }
    movers[i].update();
    movers[i].display();
  }
}
----

[[chapter02_exercise10]]
.Exercise 2.10
==================
Change the attraction force in Example 2.8 to a repulsion force.  Can you create an example in which all of the [klass]*Mover* objects are attracted to the mouse, but repel each other?  Think about how you need to balance the relative strength of the forces and how to most effectively use distance in your force calculations.
==================

[TIP]
.The Ecosystem Project
==================
Step 2 Exercise:

Incorporate the concept of forces into your ecosystem.   Try introducing other elements into the environment (food, a predator) for the creature to interact with.   Does the creature experience attraction or repulsion to things in its world?  Can you think more abstractly and design forces based on the creature’s desires or goals?
==================

